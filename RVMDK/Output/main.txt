; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Output\main.o --depend=.\Output\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\User -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\FreeRTOS\Source\include -I..\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\RVMDK -ID:\keil\ARM\INC -ID:\keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  TaskB PROC
;;;295    /*------------------------这个任务作为接受消息队列使用，类似小蜜蜂用法-----------------------------------*/
;;;296    void TaskB( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;297    {
;;;298        int16_t ReceiveNum = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;299        for( ;; )
000006  bf00              NOP      
                  |L1.8|
;;;300        {
;;;301            /* 从队列中获取内容 */
;;;302            if( xQueueReceive( MsgQueue, &ReceiveNum, 100/portTICK_RATE_MS ) == pdPASS)
000008  2300              MOVS     r3,#0
00000a  2264              MOVS     r2,#0x64
00000c  4669              MOV      r1,sp
00000e  489a              LDR      r0,|L1.632|
000010  6800              LDR      r0,[r0,#0]  ; MsgQueue
000012  f7fffffe          BL       xQueueGenericReceive
000016  e7f7              B        |L1.8|
;;;303            {
;;;304                //printf("ReceiveNum:%d\r\n",ReceiveNum);
;;;305            }
;;;306        }
;;;307    }
;;;308    static void prvSetupHardware( void )
                          ENDP

                  TaskA PROC
;;;282    /*------------------------这个任务1秒发送一次显示状态-----------------------------------*/
;;;283    void TaskA( void *pvParameters )
000018  b508              PUSH     {r3,lr}
;;;284    {
;;;285        int16_t SendNum = 1;
00001a  2001              MOVS     r0,#1
00001c  9000              STR      r0,[sp,#0]
;;;286    	//xTimerStart(Receive_Timer, 0);
;;;287        for( ;; )
00001e  bf00              NOP      
                  |L1.32|
;;;288        {
;;;289            vTaskDelay( 1000/portTICK_RATE_MS );
000020  f44f707a          MOV      r0,#0x3e8
000024  f7fffffe          BL       vTaskDelay
;;;290            /* 向队列中填充内容 */
;;;291            xQueueSend( MsgQueue, ( void* )&SendNum, 0 );
000028  2300              MOVS     r3,#0
00002a  461a              MOV      r2,r3
00002c  4669              MOV      r1,sp
00002e  4892              LDR      r0,|L1.632|
000030  6800              LDR      r0,[r0,#0]  ; MsgQueue
000032  f7fffffe          BL       xQueueGenericSend
;;;292            SendNum++;
000036  f8bd0000          LDRH     r0,[sp,#0]
00003a  1c40              ADDS     r0,r0,#1
00003c  b200              SXTH     r0,r0
00003e  9000              STR      r0,[sp,#0]
000040  e7ee              B        |L1.32|
;;;293        }
;;;294    }
;;;295    /*------------------------这个任务作为接受消息队列使用，类似小蜜蜂用法-----------------------------------*/
                          ENDP

                  Receive_TimeOut PROC
;;;73     
;;;74     void Receive_TimeOut(xTimerHandle handle) //20ms的timeout，时间到了将接收的字符串吐出
000042  b510              PUSH     {r4,lr}
;;;75     {
000044  4604              MOV      r4,r0
;;;76     	//printf("\r\n =========line = %d======%s====\r\n",__LINE__,__FILE__);
;;;77     
;;;78     	USART_RX_BUF[index_receive] = '\0';
000046  2000              MOVS     r0,#0
000048  498c              LDR      r1,|L1.636|
00004a  4a8d              LDR      r2,|L1.640|
00004c  6812              LDR      r2,[r2,#0]  ; index_receive
00004e  5488              STRB     r0,[r1,r2]
;;;79     	//printf("\r\n =========line = %d======%s====\r\n",__LINE__,USART_RX_BUF);
;;;80     
;;;81     	if(strcmp(USART_RX_BUF,"start")==0)
000050  a18c              ADR      r1,|L1.644|
000052  488a              LDR      r0,|L1.636|
000054  f7fffffe          BL       strcmp
000058  b920              CBNZ     r0,|L1.100|
;;;82     	{
;;;83     		 printf("\r\n =========line = %d======%s====\r\n",__LINE__,__FILE__);
00005a  a28c              ADR      r2,|L1.652|
00005c  2153              MOVS     r1,#0x53
00005e  a08f              ADR      r0,|L1.668|
000060  f7fffffe          BL       __2printf
                  |L1.100|
;;;84     	}
;;;85     	if(strcmp(USART_RX_BUF,"stop")==0)
000064  a196              ADR      r1,|L1.704|
000066  4885              LDR      r0,|L1.636|
000068  f7fffffe          BL       strcmp
00006c  b920              CBNZ     r0,|L1.120|
;;;86     	{
;;;87     		 printf("\r\n =========line = %d======%s====\r\n",__LINE__,__FILE__);
00006e  a287              ADR      r2,|L1.652|
000070  2157              MOVS     r1,#0x57
000072  a08a              ADR      r0,|L1.668|
000074  f7fffffe          BL       __2printf
                  |L1.120|
;;;88     	}
;;;89     
;;;90     	index_receive = 0;
000078  2000              MOVS     r0,#0
00007a  4981              LDR      r1,|L1.640|
00007c  6008              STR      r0,[r1,#0]  ; index_receive
;;;91     	memset(USART_RX_BUF,0,USART_REC_LEN*sizeof(char));
00007e  2140              MOVS     r1,#0x40
000080  487e              LDR      r0,|L1.636|
000082  f7fffffe          BL       __aeabi_memclr
;;;92         return;
;;;93     }
000086  bd10              POP      {r4,pc}
;;;94     
                          ENDP

                  USART_Configuration PROC
;;;224    *******************************************************************************/
;;;225    void USART_Configuration(void)
000088  b500              PUSH     {lr}
;;;226    {
00008a  b087              SUB      sp,sp,#0x1c
;;;227      USART_InitTypeDef USART_InitStructure;
;;;228      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;229    	USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
00008c  2000              MOVS     r0,#0
00008e  f8ad0004          STRH     r0,[sp,#4]
;;;230    	USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
000092  f8ad0006          STRH     r0,[sp,#6]
;;;231    	USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000096  f44f7000          MOV      r0,#0x200
00009a  f8ad0008          STRH     r0,[sp,#8]
;;;232    	USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
00009e  2000              MOVS     r0,#0
0000a0  f8ad000a          STRH     r0,[sp,#0xa]
;;;233    	/* Configure the USART1 synchronous paramters */
;;;234    	USART_ClockInit(USART1, &USART_ClockInitStructure);
0000a4  a901              ADD      r1,sp,#4
0000a6  4888              LDR      r0,|L1.712|
0000a8  f7fffffe          BL       USART_ClockInit
;;;235    	
;;;236    	USART_InitStructure.USART_BaudRate = 115200;
0000ac  f44f30e1          MOV      r0,#0x1c200
0000b0  9003              STR      r0,[sp,#0xc]
;;;237    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000b2  2000              MOVS     r0,#0
0000b4  f8ad0010          STRH     r0,[sp,#0x10]
;;;238    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000b8  f8ad0012          STRH     r0,[sp,#0x12]
;;;239    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000bc  f8ad0014          STRH     r0,[sp,#0x14]
;;;240    	USART_InitStructure.USART_HardwareFlowControl = 
0000c0  f8ad0018          STRH     r0,[sp,#0x18]
;;;241    	
;;;242    	USART_HardwareFlowControl_None;
;;;243    	
;;;244    	
;;;245    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000c4  200c              MOVS     r0,#0xc
0000c6  f8ad0016          STRH     r0,[sp,#0x16]
;;;246    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
0000ca  2201              MOVS     r2,#1
0000cc  f2405125          MOV      r1,#0x525
0000d0  487d              LDR      r0,|L1.712|
0000d2  f7fffffe          BL       USART_ITConfig
;;;247    	/* Configure USART1 basic and asynchronous paramters */
;;;248    	USART_Init(USART1, &USART_InitStructure);
0000d6  a903              ADD      r1,sp,#0xc
0000d8  487b              LDR      r0,|L1.712|
0000da  f7fffffe          BL       USART_Init
;;;249        
;;;250      	/* Enable USART1 */
;;;251      	USART_Cmd(USART1, ENABLE);
0000de  2101              MOVS     r1,#1
0000e0  4879              LDR      r0,|L1.712|
0000e2  f7fffffe          BL       USART_Cmd
;;;252    }
0000e6  b007              ADD      sp,sp,#0x1c
0000e8  bd00              POP      {pc}
;;;253    
                          ENDP

                  GPIO_Configuration PROC
;;;201    *******************************************************************************/
;;;202    void GPIO_Configuration(void)
0000ea  b508              PUSH     {r3,lr}
;;;203    {
;;;204      GPIO_InitTypeDef GPIO_InitStructure;
;;;205    
;;;206      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;207      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
0000ec  f44f7000          MOV      r0,#0x200
0000f0  f8ad0000          STRH     r0,[sp,#0]
;;;208      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000f4  2018              MOVS     r0,#0x18
0000f6  f88d0003          STRB     r0,[sp,#3]
;;;209      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000fa  2003              MOVS     r0,#3
0000fc  f88d0002          STRB     r0,[sp,#2]
;;;210      GPIO_Init(GPIOA, &GPIO_InitStructure);
000100  4669              MOV      r1,sp
000102  4872              LDR      r0,|L1.716|
000104  f7fffffe          BL       GPIO_Init
;;;211        
;;;212      /* Configure USART1 Rx (PA.10) as input floating */
;;;213      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000108  f44f6080          MOV      r0,#0x400
00010c  f8ad0000          STRH     r0,[sp,#0]
;;;214      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000110  2004              MOVS     r0,#4
000112  f88d0003          STRB     r0,[sp,#3]
;;;215      GPIO_Init(GPIOA, &GPIO_InitStructure);
000116  4669              MOV      r1,sp
000118  486c              LDR      r0,|L1.716|
00011a  f7fffffe          BL       GPIO_Init
;;;216    }
00011e  bd08              POP      {r3,pc}
;;;217    
                          ENDP

                  NVIC_Configuration PROC
;;;177    *******************************************************************************/
;;;178    void NVIC_Configuration(void)
000120  b508              PUSH     {r3,lr}
;;;179    {
;;;180    	NVIC_InitTypeDef NVIC_InitStructure;
;;;181    #ifdef  VECT_TAB_RAM  
;;;182      /* Set the Vector Table base location at 0x20000000 */ 
;;;183      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;184    #else  /* VECT_TAB_FLASH  */
;;;185      /* Set the Vector Table base location at 0x08000000 */ 
;;;186      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000122  2100              MOVS     r1,#0
000124  f04f6000          MOV      r0,#0x8000000
000128  f7fffffe          BL       NVIC_SetVectorTable
;;;187    #endif
;;;188    	NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;
00012c  2025              MOVS     r0,#0x25
00012e  f88d0000          STRB     r0,[sp,#0]
;;;189    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;
000132  2000              MOVS     r0,#0
000134  f88d0001          STRB     r0,[sp,#1]
;;;190    	NVIC_InitStructure.NVIC_IRQChannelSubPriority=0;
000138  f88d0002          STRB     r0,[sp,#2]
;;;191    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00013c  2001              MOVS     r0,#1
00013e  f88d0003          STRB     r0,[sp,#3]
;;;192    	NVIC_Init(&NVIC_InitStructure);
000142  4668              MOV      r0,sp
000144  f7fffffe          BL       NVIC_Init
;;;193    }
000148  bd08              POP      {r3,pc}
;;;194    
                          ENDP

                  RCC_Configuration PROC
;;;119    *******************************************************************************/
;;;120    void RCC_Configuration(void)
00014a  b510              PUSH     {r4,lr}
;;;121    {
;;;122      /* RCC system reset(for debug purpose) */
;;;123      RCC_DeInit();
00014c  f7fffffe          BL       RCC_DeInit
;;;124    
;;;125      /* Enable HSE */
;;;126      RCC_HSEConfig(RCC_HSE_ON);
000150  f44f3080          MOV      r0,#0x10000
000154  f7fffffe          BL       RCC_HSEConfig
;;;127    
;;;128      /* Wait till HSE is ready */
;;;129      HSEStartUpStatus = RCC_WaitForHSEStartUp();
000158  f7fffffe          BL       RCC_WaitForHSEStartUp
00015c  495c              LDR      r1,|L1.720|
00015e  7008              STRB     r0,[r1,#0]
;;;130    
;;;131      if(HSEStartUpStatus == SUCCESS)
000160  4608              MOV      r0,r1
000162  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
000164  2801              CMP      r0,#1
000166  d126              BNE      |L1.438|
;;;132      {
;;;133        /* HCLK = SYSCLK */
;;;134        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
000168  2000              MOVS     r0,#0
00016a  f7fffffe          BL       RCC_HCLKConfig
;;;135      
;;;136        /* PCLK2 = HCLK */
;;;137        RCC_PCLK2Config(RCC_HCLK_Div1); 
00016e  2000              MOVS     r0,#0
000170  f7fffffe          BL       RCC_PCLK2Config
;;;138    
;;;139        /* PCLK1 = HCLK/2 */
;;;140        RCC_PCLK1Config(RCC_HCLK_Div2);
000174  f44f6080          MOV      r0,#0x400
000178  f7fffffe          BL       RCC_PCLK1Config
;;;141    
;;;142        /* Flash 2 wait state */
;;;143        FLASH_SetLatency(FLASH_Latency_2);
00017c  2002              MOVS     r0,#2
00017e  f7fffffe          BL       FLASH_SetLatency
;;;144        /* Enable Prefetch Buffer */
;;;145        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000182  2010              MOVS     r0,#0x10
000184  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;146    
;;;147        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;148        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000188  f44f11e0          MOV      r1,#0x1c0000
00018c  f44f3080          MOV      r0,#0x10000
000190  f7fffffe          BL       RCC_PLLConfig
;;;149    
;;;150        /* Enable PLL */ 
;;;151        RCC_PLLCmd(ENABLE);
000194  2001              MOVS     r0,#1
000196  f7fffffe          BL       RCC_PLLCmd
;;;152    
;;;153        /* Wait till PLL is ready */
;;;154        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00019a  bf00              NOP      
                  |L1.412|
00019c  2039              MOVS     r0,#0x39
00019e  f7fffffe          BL       RCC_GetFlagStatus
0001a2  2800              CMP      r0,#0
0001a4  d0fa              BEQ      |L1.412|
;;;155        {
;;;156        }
;;;157    
;;;158        /* Select PLL as system clock source */
;;;159        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
0001a6  2002              MOVS     r0,#2
0001a8  f7fffffe          BL       RCC_SYSCLKConfig
;;;160    
;;;161        /* Wait till PLL is used as system clock source */
;;;162        while(RCC_GetSYSCLKSource() != 0x08)
0001ac  bf00              NOP      
                  |L1.430|
0001ae  f7fffffe          BL       RCC_GetSYSCLKSource
0001b2  2808              CMP      r0,#8
0001b4  d1fb              BNE      |L1.430|
                  |L1.438|
;;;163        {
;;;164        }
;;;165      }
;;;166       
;;;167      /* Enable USART1 and GPIOA clock */
;;;168      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
0001b6  2101              MOVS     r1,#1
0001b8  f2440004          MOV      r0,#0x4004
0001bc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;169    }
0001c0  bd10              POP      {r4,pc}
;;;170    
                          ENDP

                  prvSetupHardware PROC
;;;307    }
;;;308    static void prvSetupHardware( void )
0001c2  b510              PUSH     {r4,lr}
;;;309    {
;;;310    	RCC_Configuration();
0001c4  f7fffffe          BL       RCC_Configuration
;;;311    	NVIC_Configuration();
0001c8  f7fffffe          BL       NVIC_Configuration
;;;312    	GPIO_Configuration();
0001cc  f7fffffe          BL       GPIO_Configuration
;;;313    	USART_Configuration();
0001d0  f7fffffe          BL       USART_Configuration
;;;314    }
0001d4  bd10              POP      {r4,pc}
                          ENDP

                  main PROC
;;;46     
;;;47     int main(void)
0001d6  b51f              PUSH     {r0-r4,lr}
;;;48     {
;;;49     	/* 初始化硬件平台 */
;;;50         prvSetupHardware();
0001d8  f7fffffe          BL       prvSetupHardware
;;;51     
;;;52     	printf("\r\n Welcome to ,Hello WH \r\n");
0001dc  a03d              ADR      r0,|L1.724|
0001de  f7fffffe          BL       __2printf
;;;53     	printf("\r\n =========line = %d======%s====\r\n",__LINE__,__FILE__);
0001e2  a22a              ADR      r2,|L1.652|
0001e4  2135              MOVS     r1,#0x35
0001e6  a02d              ADR      r0,|L1.668|
0001e8  f7fffffe          BL       __2printf
;;;54     	/* create sw timer, 2s */
;;;55         Receive_Timer = xTimerCreate((const char*)"ReceiveTimer",\
0001ec  f2af13ad          ADR      r3,Receive_TimeOut + 1
0001f0  9300              STR      r3,[sp,#0]
0001f2  2300              MOVS     r3,#0
0001f4  461a              MOV      r2,r3
0001f6  2114              MOVS     r1,#0x14
0001f8  a03d              ADR      r0,|L1.752|
0001fa  f7fffffe          BL       xTimerCreate
0001fe  4940              LDR      r1,|L1.768|
000200  6008              STR      r0,[r1,#0]  ; Receive_Timer
;;;56                             20 / portTICK_RATE_MS, pdFALSE, NULL, Receive_TimeOut);
;;;57     	/* 建立队列 */
;;;58         MsgQueue = xQueueCreate( 5 , sizeof( int16_t ) );
000202  2200              MOVS     r2,#0
000204  2102              MOVS     r1,#2
000206  2005              MOVS     r0,#5
000208  f7fffffe          BL       xQueueGenericCreate
00020c  491a              LDR      r1,|L1.632|
00020e  6008              STR      r0,[r1,#0]  ; MsgQueue
;;;59     	CmdMsg   = xQueueCreate( 5 , sizeof( int16_t ) );
000210  2200              MOVS     r2,#0
000212  2102              MOVS     r1,#2
000214  2005              MOVS     r0,#5
000216  f7fffffe          BL       xQueueGenericCreate
00021a  493a              LDR      r1,|L1.772|
00021c  6008              STR      r0,[r1,#0]  ; CmdMsg
;;;60         /* 建立任务 */
;;;61         xTaskCreate( TaskA, ( signed portCHAR * ) "TaskA", configMINIMAL_STACK_SIZE,
00021e  2300              MOVS     r3,#0
000220  2003              MOVS     r0,#3
000222  e9cd0300          STRD     r0,r3,[sp,#0]
000226  9302              STR      r3,[sp,#8]
000228  2280              MOVS     r2,#0x80
00022a  a137              ADR      r1,|L1.776|
00022c  f2af2017          ADR      r0,TaskA + 1
000230  9303              STR      r3,[sp,#0xc]
000232  f7fffffe          BL       xTaskGenericCreate
;;;62                                 NULL, tskIDLE_PRIORITY+3, NULL );
;;;63         xTaskCreate( TaskB, ( signed portCHAR * ) "TaskB", configMINIMAL_STACK_SIZE,
000236  2300              MOVS     r3,#0
000238  2004              MOVS     r0,#4
00023a  e9cd0300          STRD     r0,r3,[sp,#0]
00023e  9302              STR      r3,[sp,#8]
000240  2280              MOVS     r2,#0x80
000242  a133              ADR      r1,|L1.784|
000244  f2af2047          ADR      r0,TaskB + 1
000248  9303              STR      r3,[sp,#0xc]
00024a  f7fffffe          BL       xTaskGenericCreate
;;;64                                 NULL, tskIDLE_PRIORITY+4, NULL );
;;;65         /* 启动OS */
;;;66         vTaskStartScheduler();
00024e  f7fffffe          BL       vTaskStartScheduler
;;;67        
;;;68         return 0;
000252  2000              MOVS     r0,#0
;;;69     
;;;70     
;;;71     	
;;;72     }
000254  b004              ADD      sp,sp,#0x10
000256  bd10              POP      {r4,pc}
;;;73     
                          ENDP

                  fputc PROC
;;;260    *******************************************************************************/
;;;261    int fputc(int ch, FILE *f)
000258  b570              PUSH     {r4-r6,lr}
;;;262    {
00025a  4604              MOV      r4,r0
00025c  460d              MOV      r5,r1
;;;263      /* Place your implementation of fputc here */
;;;264      /* e.g. write a character to the USART */
;;;265      USART_SendData(USART1, (u8) ch);
00025e  b2e1              UXTB     r1,r4
000260  4819              LDR      r0,|L1.712|
000262  f7fffffe          BL       USART_SendData
;;;266    
;;;267      /* Loop until the end of transmission */
;;;268      while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
000266  bf00              NOP      
                  |L1.616|
000268  2140              MOVS     r1,#0x40
00026a  4817              LDR      r0,|L1.712|
00026c  f7fffffe          BL       USART_GetFlagStatus
000270  2800              CMP      r0,#0
000272  d0f9              BEQ      |L1.616|
;;;269      {
;;;270      }
;;;271    
;;;272      return ch;
000274  4620              MOV      r0,r4
;;;273    }
000276  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

                  |L1.632|
                          DCD      MsgQueue
                  |L1.636|
                          DCD      USART_RX_BUF
                  |L1.640|
                          DCD      index_receive
                  |L1.644|
000284  73746172          DCB      "start",0
000288  7400    
00028a  00                DCB      0
00028b  00                DCB      0
                  |L1.652|
00028c  2e2e5c55          DCB      "..\\User\\main.c",0
000290  7365725c
000294  6d61696e
000298  2e6300  
00029b  00                DCB      0
                  |L1.668|
00029c  0d0a203d          DCB      "\r\n =========line = %d======%s====\r\n",0
0002a0  3d3d3d3d
0002a4  3d3d3d3d
0002a8  6c696e65
0002ac  203d2025
0002b0  643d3d3d
0002b4  3d3d3d25
0002b8  733d3d3d
0002bc  3d0d0a00
                  |L1.704|
0002c0  73746f70          DCB      "stop",0
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L1.712|
                          DCD      0x40013800
                  |L1.716|
                          DCD      0x40010800
                  |L1.720|
                          DCD      HSEStartUpStatus
                  |L1.724|
0002d4  0d0a2057          DCB      "\r\n Welcome to ,Hello WH \r\n",0
0002d8  656c636f
0002dc  6d652074
0002e0  6f202c48
0002e4  656c6c6f
0002e8  20574820
0002ec  0d0a00  
0002ef  00                DCB      0
                  |L1.752|
0002f0  52656365          DCB      "ReceiveTimer",0
0002f4  69766554
0002f8  696d6572
0002fc  00      
0002fd  00                DCB      0
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L1.768|
                          DCD      Receive_Timer
                  |L1.772|
                          DCD      CmdMsg
                  |L1.776|
000308  5461736b          DCB      "TaskA",0
00030c  4100    
00030e  00                DCB      0
00030f  00                DCB      0
                  |L1.784|
000310  5461736b          DCB      "TaskB",0
000314  4200    
000316  00                DCB      0
000317  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  Receive_Timer
                          DCD      0x00000000
                  HSEStartUpStatus
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  MsgQueue
                          DCD      0x00000000
                  CmdMsg
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
