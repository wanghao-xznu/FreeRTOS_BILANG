; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Output\tasks.o --depend=.\Output\tasks.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\User -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\FreeRTOS\Source\include -I..\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\RVMDK -ID:\keil\ARM\INC -ID:\keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Output\tasks.crf ..\FreeRTOS\Source\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;2997   
;;;2998   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;2999   {
;;;3000   UBaseType_t uxPriority;
;;;3001   
;;;3002   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L1.22|
                  |L1.6|
;;;3003   	{
;;;3004   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4aff              LDR      r2,|L1.1032|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3002
                  |L1.22|
000016  2c05              CMP      r4,#5                 ;3002
000018  d3f5              BCC      |L1.6|
;;;3005   	}
;;;3006   
;;;3007   	vListInitialise( &xDelayedTaskList1 );
00001a  48fc              LDR      r0,|L1.1036|
00001c  f7fffffe          BL       vListInitialise
;;;3008   	vListInitialise( &xDelayedTaskList2 );
000020  48fb              LDR      r0,|L1.1040|
000022  f7fffffe          BL       vListInitialise
;;;3009   	vListInitialise( &xPendingReadyList );
000026  48fb              LDR      r0,|L1.1044|
000028  f7fffffe          BL       vListInitialise
;;;3010   
;;;3011   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3012   	{
;;;3013   		vListInitialise( &xTasksWaitingTermination );
00002c  48fa              LDR      r0,|L1.1048|
00002e  f7fffffe          BL       vListInitialise
;;;3014   	}
;;;3015   	#endif /* INCLUDE_vTaskDelete */
;;;3016   
;;;3017   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3018   	{
;;;3019   		vListInitialise( &xSuspendedTaskList );
000032  48fa              LDR      r0,|L1.1052|
000034  f7fffffe          BL       vListInitialise
;;;3020   	}
;;;3021   	#endif /* INCLUDE_vTaskSuspend */
;;;3022   
;;;3023   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3024   	using list2. */
;;;3025   	pxDelayedTaskList = &xDelayedTaskList1;
000038  48f4              LDR      r0,|L1.1036|
00003a  49f9              LDR      r1,|L1.1056|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3026   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  48f4              LDR      r0,|L1.1040|
000040  49f8              LDR      r1,|L1.1060|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3027   }
000044  bd10              POP      {r4,pc}
;;;3028   /*-----------------------------------------------------------*/
                          ENDP

                  prvInitialiseTCBVariables PROC
;;;2832   
;;;2833   static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000046  e92d47f0          PUSH     {r4-r10,lr}
;;;2834   {
00004a  4604              MOV      r4,r0
00004c  460f              MOV      r7,r1
00004e  4616              MOV      r6,r2
000050  4699              MOV      r9,r3
000052  f8dd8020          LDR      r8,[sp,#0x20]
;;;2835   UBaseType_t x;
;;;2836   
;;;2837   	/* Store the task name in the TCB. */
;;;2838   	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000056  2500              MOVS     r5,#0
000058  e007              B        |L1.106|
                  |L1.90|
;;;2839   	{
;;;2840   		pxTCB->pcTaskName[ x ] = pcName[ x ];
00005a  5d79              LDRB     r1,[r7,r5]
00005c  f1040034          ADD      r0,r4,#0x34
000060  5541              STRB     r1,[r0,r5]
;;;2841   
;;;2842   		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;2843   		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;2844   		string is not accessible (extremely unlikely). */
;;;2845   		if( pcName[ x ] == 0x00 )
000062  5d78              LDRB     r0,[r7,r5]
000064  b900              CBNZ     r0,|L1.104|
;;;2846   		{
;;;2847   			break;
000066  e002              B        |L1.110|
                  |L1.104|
000068  1c6d              ADDS     r5,r5,#1              ;2838
                  |L1.106|
00006a  2d10              CMP      r5,#0x10              ;2838
00006c  d3f5              BCC      |L1.90|
                  |L1.110|
00006e  bf00              NOP      
;;;2848   		}
;;;2849   		else
;;;2850   		{
;;;2851   			mtCOVERAGE_TEST_MARKER();
;;;2852   		}
;;;2853   	}
;;;2854   
;;;2855   	/* Ensure the name string is terminated in the case that the string length
;;;2856   	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;2857   	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000070  2100              MOVS     r1,#0
000072  2043              MOVS     r0,#0x43
000074  5501              STRB     r1,[r0,r4]
;;;2858   
;;;2859   	/* This is used as an array index so must ensure it's not too large.  First
;;;2860   	remove the privilege bit if one is present. */
;;;2861   	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000076  2e05              CMP      r6,#5
000078  d300              BCC      |L1.124|
;;;2862   	{
;;;2863   		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00007a  2604              MOVS     r6,#4
                  |L1.124|
;;;2864   	}
;;;2865   	else
;;;2866   	{
;;;2867   		mtCOVERAGE_TEST_MARKER();
;;;2868   	}
;;;2869   
;;;2870   	pxTCB->uxPriority = uxPriority;
00007c  62e6              STR      r6,[r4,#0x2c]
;;;2871   	#if ( configUSE_MUTEXES == 1 )
;;;2872   	{
;;;2873   		pxTCB->uxBasePriority = uxPriority;
;;;2874   		pxTCB->uxMutexesHeld = 0;
;;;2875   	}
;;;2876   	#endif /* configUSE_MUTEXES */
;;;2877   
;;;2878   	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
00007e  1d20              ADDS     r0,r4,#4
000080  f7fffffe          BL       vListInitialiseItem
;;;2879   	vListInitialiseItem( &( pxTCB->xEventListItem ) );
000084  f1040018          ADD      r0,r4,#0x18
000088  f7fffffe          BL       vListInitialiseItem
;;;2880   
;;;2881   	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
;;;2882   	back to	the containing TCB from a generic item in a list. */
;;;2883   	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
00008c  6124              STR      r4,[r4,#0x10]
;;;2884   
;;;2885   	/* Event lists are always in priority order. */
;;;2886   	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008e  f1c60005          RSB      r0,r6,#5
000092  61a0              STR      r0,[r4,#0x18]
;;;2887   	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
000094  6264              STR      r4,[r4,#0x24]
;;;2888   
;;;2889   	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;2890   	{
;;;2891   		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;2892   	}
;;;2893   	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;2894   
;;;2895   	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;2896   	{
;;;2897   		pxTCB->pxTaskTag = NULL;
;;;2898   	}
;;;2899   	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;2900   
;;;2901   	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2902   	{
;;;2903   		pxTCB->ulRunTimeCounter = 0UL;
;;;2904   	}
;;;2905   	#endif /* configGENERATE_RUN_TIME_STATS */
;;;2906   
;;;2907   	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;2908   	{
;;;2909   		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
;;;2910   	}
;;;2911   	#else /* portUSING_MPU_WRAPPERS */
;;;2912   	{
;;;2913   		( void ) xRegions;
;;;2914   		( void ) usStackDepth;
;;;2915   	}
;;;2916   	#endif /* portUSING_MPU_WRAPPERS */
;;;2917   
;;;2918   	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;2919   	{
;;;2920   		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;2921   		{
;;;2922   			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;2923   		}
;;;2924   	}
;;;2925   	#endif
;;;2926   
;;;2927   	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;2928   	{
;;;2929   		pxTCB->ulNotifiedValue = 0;
000096  2000              MOVS     r0,#0
000098  6460              STR      r0,[r4,#0x44]
;;;2930   		pxTCB->eNotifyState = eNotWaitingNotification;
00009a  f8840048          STRB     r0,[r4,#0x48]
;;;2931   	}
;;;2932   	#endif
;;;2933   
;;;2934   	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2935   	{
;;;2936   		/* Initialise this task's Newlib reent structure. */
;;;2937   		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
;;;2938   	}
;;;2939   	#endif /* configUSE_NEWLIB_REENTRANT */
;;;2940   }
00009e  e8bd87f0          POP      {r4-r10,pc}
;;;2941   /*-----------------------------------------------------------*/
                          ENDP

                  prvAllocateTCBAndStack PROC
;;;3100   
;;;3101   static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
0000a2  e92d41f0          PUSH     {r4-r8,lr}
;;;3102   {
0000a6  4606              MOV      r6,r0
0000a8  460f              MOV      r7,r1
;;;3103   TCB_t *pxNewTCB;
;;;3104   
;;;3105   	/* If the stack grows down then allocate the stack then the TCB so the stack
;;;3106   	does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;3107   	the TCB then the stack. */
;;;3108   	#if( portSTACK_GROWTH > 0 )
;;;3109   	{
;;;3110   		/* Allocate space for the TCB.  Where the memory comes from depends on
;;;3111   		the implementation of the port malloc function. */
;;;3112   		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;3113   
;;;3114   		if( pxNewTCB != NULL )
;;;3115   		{
;;;3116   			/* Allocate space for the stack used by the task being created.
;;;3117   			The base of the stack memory stored in the TCB so the task can
;;;3118   			be deleted later if required. */
;;;3119   			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;3120   
;;;3121   			if( pxNewTCB->pxStack == NULL )
;;;3122   			{
;;;3123   				/* Could not allocate the stack.  Delete the allocated TCB. */
;;;3124   				vPortFree( pxNewTCB );
;;;3125   				pxNewTCB = NULL;
;;;3126   			}
;;;3127   		}
;;;3128   	}
;;;3129   	#else /* portSTACK_GROWTH */
;;;3130   	{
;;;3131   	StackType_t *pxStack;
;;;3132   
;;;3133   		/* Allocate space for the stack used by the task being created. */
;;;3134   		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000aa  b91f              CBNZ     r7,|L1.180|
0000ac  00b0              LSLS     r0,r6,#2
0000ae  f7fffffe          BL       pvPortMalloc
0000b2  e000              B        |L1.182|
                  |L1.180|
0000b4  4638              MOV      r0,r7
                  |L1.182|
0000b6  4605              MOV      r5,r0
;;;3135   
;;;3136   		if( pxStack != NULL )
0000b8  b155              CBZ      r5,|L1.208|
;;;3137   		{
;;;3138   			/* Allocate space for the TCB.  Where the memory comes from depends
;;;3139   			on the implementation of the port malloc function. */
;;;3140   			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
0000ba  204c              MOVS     r0,#0x4c
0000bc  f7fffffe          BL       pvPortMalloc
0000c0  4604              MOV      r4,r0
;;;3141   
;;;3142   			if( pxNewTCB != NULL )
0000c2  b10c              CBZ      r4,|L1.200|
;;;3143   			{
;;;3144   				/* Store the stack location in the TCB. */
;;;3145   				pxNewTCB->pxStack = pxStack;
0000c4  6325              STR      r5,[r4,#0x30]
0000c6  e004              B        |L1.210|
                  |L1.200|
;;;3146   			}
;;;3147   			else
;;;3148   			{
;;;3149   				/* The stack cannot be used as the TCB was not created.  Free it
;;;3150   				again. */
;;;3151   				vPortFree( pxStack );
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       vPortFree
0000ce  e000              B        |L1.210|
                  |L1.208|
;;;3152   			}
;;;3153   		}
;;;3154   		else
;;;3155   		{
;;;3156   			pxNewTCB = NULL;
0000d0  2400              MOVS     r4,#0
                  |L1.210|
;;;3157   		}
;;;3158   	}
;;;3159   	#endif /* portSTACK_GROWTH */
;;;3160   
;;;3161   	if( pxNewTCB != NULL )
;;;3162   	{
;;;3163   		/* Avoid dependency on memset() if it is not required. */
;;;3164   		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;3165   		{
;;;3166   			/* Just to help debugging. */
;;;3167   			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
;;;3168   		}
;;;3169   		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;3170   	}
;;;3171   
;;;3172   	return pxNewTCB;
0000d2  4620              MOV      r0,r4
;;;3173   }
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;3174   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGenericCreate PROC
;;;550    
;;;551    BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
0000d8  e92d4fff          PUSH     {r0-r11,lr}
;;;552    {
0000dc  b081              SUB      sp,sp,#4
0000de  4680              MOV      r8,r0
0000e0  4615              MOV      r5,r2
0000e2  4699              MOV      r9,r3
0000e4  e9dd7a0e          LDRD     r7,r10,[sp,#0x38]
;;;553    BaseType_t xReturn;
;;;554    TCB_t * pxNewTCB;
;;;555    StackType_t *pxTopOfStack;
;;;556    
;;;557    	configASSERT( pxTaskCode );
;;;558    	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
;;;559    
;;;560    	/* Allocate the memory required by the TCB and stack for the new task,
;;;561    	checking that the allocation was successful. */
;;;562    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
0000e8  4628              MOV      r0,r5
0000ea  9910              LDR      r1,[sp,#0x40]
0000ec  f7fffffe          BL       prvAllocateTCBAndStack
0000f0  4604              MOV      r4,r0
;;;563    
;;;564    	if( pxNewTCB != NULL )
0000f2  b3f4              CBZ      r4,|L1.370|
;;;565    	{
;;;566    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;567    			/* Should the task be created in privileged mode? */
;;;568    			BaseType_t xRunPrivileged;
;;;569    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;570    			{
;;;571    				xRunPrivileged = pdTRUE;
;;;572    			}
;;;573    			else
;;;574    			{
;;;575    				xRunPrivileged = pdFALSE;
;;;576    			}
;;;577    			uxPriority &= ~portPRIVILEGE_BIT;
;;;578    
;;;579    			if( puxStackBuffer != NULL )
;;;580    			{
;;;581    				/* The application provided its own stack.  Note this so no
;;;582    				attempt is made to delete the stack should that task be
;;;583    				deleted. */
;;;584    				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
;;;585    			}
;;;586    			else
;;;587    			{
;;;588    				/* The stack was allocated dynamically.  Note this so it can be
;;;589    				deleted again if the task is deleted. */
;;;590    				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
;;;591    			}
;;;592    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;593    
;;;594    		/* Calculate the top of stack address.  This depends on whether the
;;;595    		stack grows from high memory to low (as per the 80x86) or vice versa.
;;;596    		portSTACK_GROWTH is used to make the result positive or negative as
;;;597    		required by the port. */
;;;598    		#if( portSTACK_GROWTH < 0 )
;;;599    		{
;;;600    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
0000f4  1e68              SUBS     r0,r5,#1
0000f6  6b21              LDR      r1,[r4,#0x30]
0000f8  eb010b80          ADD      r11,r1,r0,LSL #2
;;;601    			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
0000fc  f02b0b07          BIC      r11,r11,#7
;;;602    
;;;603    			/* Check the alignment of the calculated top of stack is correct. */
;;;604    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;605    		}
;;;606    		#else /* portSTACK_GROWTH */
;;;607    		{
;;;608    			pxTopOfStack = pxNewTCB->pxStack;
;;;609    
;;;610    			/* Check the alignment of the stack buffer is correct. */
;;;611    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;612    
;;;613    			/* If we want to use stack checking on architectures that use
;;;614    			a positive stack growth direction then we also need to store the
;;;615    			other extreme of the stack space. */
;;;616    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;617    		}
;;;618    		#endif /* portSTACK_GROWTH */
;;;619    
;;;620    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;621    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
000100  9500              STR      r5,[sp,#0]
000102  463a              MOV      r2,r7
000104  4620              MOV      r0,r4
000106  9b11              LDR      r3,[sp,#0x44]
000108  9902              LDR      r1,[sp,#8]
00010a  f7fffffe          BL       prvInitialiseTCBVariables
;;;622    
;;;623    		/* Initialize the TCB stack to look as if the task was already running,
;;;624    		but had been interrupted by the scheduler.  The return address is set
;;;625    		to the start of the task function. Once the stack has been initialised
;;;626    		the	top of stack variable is updated. */
;;;627    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;628    		{
;;;629    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;630    		}
;;;631    		#else /* portUSING_MPU_WRAPPERS */
;;;632    		{
;;;633    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
00010e  464a              MOV      r2,r9
000110  4641              MOV      r1,r8
000112  4658              MOV      r0,r11
000114  f7fffffe          BL       pxPortInitialiseStack
000118  6020              STR      r0,[r4,#0]
;;;634    		}
;;;635    		#endif /* portUSING_MPU_WRAPPERS */
;;;636    
;;;637    		if( ( void * ) pxCreatedTask != NULL )
00011a  f1ba0f00          CMP      r10,#0
00011e  d001              BEQ      |L1.292|
;;;638    		{
;;;639    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;640    			task can use this as a handle to delete the task later if
;;;641    			required.*/
;;;642    			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000120  f8ca4000          STR      r4,[r10,#0]
                  |L1.292|
;;;643    		}
;;;644    		else
;;;645    		{
;;;646    			mtCOVERAGE_TEST_MARKER();
;;;647    		}
;;;648    
;;;649    		/* Ensure interrupts don't access the task lists while they are being
;;;650    		updated. */
;;;651    		taskENTER_CRITICAL();
000124  f7fffffe          BL       vPortEnterCritical
;;;652    		{
;;;653    			uxCurrentNumberOfTasks++;
000128  48bf              LDR      r0,|L1.1064|
00012a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00012c  1c40              ADDS     r0,r0,#1
00012e  49be              LDR      r1,|L1.1064|
000130  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;654    			if( pxCurrentTCB == NULL )
000132  48be              LDR      r0,|L1.1068|
000134  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000136  b940              CBNZ     r0,|L1.330|
;;;655    			{
;;;656    				/* There are no other tasks, or all the other tasks are in
;;;657    				the suspended state - make this the current task. */
;;;658    				pxCurrentTCB =  pxNewTCB;
000138  48bc              LDR      r0,|L1.1068|
00013a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;659    
;;;660    				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00013c  4608              MOV      r0,r1
00013e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000140  2801              CMP      r0,#1
000142  d10c              BNE      |L1.350|
;;;661    				{
;;;662    					/* This is the first task to be created so do the preliminary
;;;663    					initialisation required.  We will not recover if this call
;;;664    					fails, but we will report the failure. */
;;;665    					prvInitialiseTaskLists();
000144  f7fffffe          BL       prvInitialiseTaskLists
000148  e009              B        |L1.350|
                  |L1.330|
;;;666    				}
;;;667    				else
;;;668    				{
;;;669    					mtCOVERAGE_TEST_MARKER();
;;;670    				}
;;;671    			}
;;;672    			else
;;;673    			{
;;;674    				/* If the scheduler is not already running, make this task the
;;;675    				current task if it is the highest priority task to be created
;;;676    				so far. */
;;;677    				if( xSchedulerRunning == pdFALSE )
00014a  48b9              LDR      r0,|L1.1072|
00014c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00014e  b930              CBNZ     r0,|L1.350|
;;;678    				{
;;;679    					if( pxCurrentTCB->uxPriority <= uxPriority )
000150  48b6              LDR      r0,|L1.1068|
000152  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000154  6ac0              LDR      r0,[r0,#0x2c]
000156  42b8              CMP      r0,r7
000158  d801              BHI      |L1.350|
;;;680    					{
;;;681    						pxCurrentTCB = pxNewTCB;
00015a  48b4              LDR      r0,|L1.1068|
00015c  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.350|
;;;682    					}
;;;683    					else
;;;684    					{
;;;685    						mtCOVERAGE_TEST_MARKER();
;;;686    					}
;;;687    				}
;;;688    				else
;;;689    				{
;;;690    					mtCOVERAGE_TEST_MARKER();
;;;691    				}
;;;692    			}
;;;693    
;;;694    			uxTaskNumber++;
00015e  48b5              LDR      r0,|L1.1076|
000160  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000162  1c40              ADDS     r0,r0,#1
000164  49b3              LDR      r1,|L1.1076|
000166  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;695    
;;;696    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;697    			{
;;;698    				/* Add a counter into the TCB for tracing only. */
;;;699    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;700    			}
;;;701    			#endif /* configUSE_TRACE_FACILITY */
;;;702    			traceTASK_CREATE( pxNewTCB );
;;;703    
;;;704    			prvAddTaskToReadyList( pxNewTCB );
000168  2001              MOVS     r0,#1
00016a  6ae1              LDR      r1,[r4,#0x2c]
00016c  4088              LSLS     r0,r0,r1
00016e  49b2              LDR      r1,|L1.1080|
000170  e000              B        |L1.372|
                  |L1.370|
000172  e010              B        |L1.406|
                  |L1.372|
000174  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000176  4308              ORRS     r0,r0,r1
000178  49af              LDR      r1,|L1.1080|
00017a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00017c  6ae1              LDR      r1,[r4,#0x2c]
00017e  eb010181          ADD      r1,r1,r1,LSL #2
000182  4aa1              LDR      r2,|L1.1032|
000184  eb020081          ADD      r0,r2,r1,LSL #2
000188  1d21              ADDS     r1,r4,#4
00018a  f7fffffe          BL       vListInsertEnd
;;;705    
;;;706    			xReturn = pdPASS;
00018e  2601              MOVS     r6,#1
;;;707    			portSETUP_TCB( pxNewTCB );
;;;708    		}
;;;709    		taskEXIT_CRITICAL();
000190  f7fffffe          BL       vPortExitCritical
000194  e001              B        |L1.410|
                  |L1.406|
;;;710    	}
;;;711    	else
;;;712    	{
;;;713    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000196  f04f36ff          MOV      r6,#0xffffffff
                  |L1.410|
;;;714    		traceTASK_CREATE_FAILED();
;;;715    	}
;;;716    
;;;717    	if( xReturn == pdPASS )
00019a  2e01              CMP      r6,#1
00019c  d109              BNE      |L1.434|
;;;718    	{
;;;719    		if( xSchedulerRunning != pdFALSE )
00019e  48a4              LDR      r0,|L1.1072|
0001a0  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
0001a2  b130              CBZ      r0,|L1.434|
;;;720    		{
;;;721    			/* If the created task is of a higher priority than the current task
;;;722    			then it should run now. */
;;;723    			if( pxCurrentTCB->uxPriority < uxPriority )
0001a4  48a1              LDR      r0,|L1.1068|
0001a6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0001a8  6ac0              LDR      r0,[r0,#0x2c]
0001aa  42b8              CMP      r0,r7
0001ac  d201              BCS      |L1.434|
;;;724    			{
;;;725    				taskYIELD_IF_USING_PREEMPTION();
0001ae  f7fffffe          BL       vPortYield
                  |L1.434|
;;;726    			}
;;;727    			else
;;;728    			{
;;;729    				mtCOVERAGE_TEST_MARKER();
;;;730    			}
;;;731    		}
;;;732    		else
;;;733    		{
;;;734    			mtCOVERAGE_TEST_MARKER();
;;;735    		}
;;;736    	}
;;;737    
;;;738    	return xReturn;
0001b2  4630              MOV      r0,r6
;;;739    }
0001b4  b005              ADD      sp,sp,#0x14
0001b6  e8bd8ff0          POP      {r4-r11,pc}
;;;740    /*-----------------------------------------------------------*/
                          ENDP

                  prvResetNextTaskUnblockTime PROC
;;;3346   
;;;3347   static void prvResetNextTaskUnblockTime( void )
0001ba  4999              LDR      r1,|L1.1056|
;;;3348   {
;;;3349   TCB_t *pxTCB;
;;;3350   
;;;3351   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0001bc  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
0001be  6809              LDR      r1,[r1,#0]
0001c0  b909              CBNZ     r1,|L1.454|
0001c2  2101              MOVS     r1,#1
0001c4  e000              B        |L1.456|
                  |L1.454|
0001c6  2100              MOVS     r1,#0
                  |L1.456|
0001c8  b121              CBZ      r1,|L1.468|
;;;3352   	{
;;;3353   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3354   		the maximum possible value so it is	extremely unlikely that the
;;;3355   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3356   		there is an item in the delayed list. */
;;;3357   		xNextTaskUnblockTime = portMAX_DELAY;
0001ca  f04f31ff          MOV      r1,#0xffffffff
0001ce  4a9b              LDR      r2,|L1.1084|
0001d0  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
0001d2  e006              B        |L1.482|
                  |L1.468|
;;;3358   	}
;;;3359   	else
;;;3360   	{
;;;3361   		/* The new current delayed list is not empty, get the value of
;;;3362   		the item at the head of the delayed list.  This is the time at
;;;3363   		which the task at the head of the delayed list should be removed
;;;3364   		from the Blocked state. */
;;;3365   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0001d4  4992              LDR      r1,|L1.1056|
0001d6  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
0001d8  68c9              LDR      r1,[r1,#0xc]
0001da  68c8              LDR      r0,[r1,#0xc]
;;;3366   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
0001dc  4a97              LDR      r2,|L1.1084|
0001de  6841              LDR      r1,[r0,#4]
0001e0  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L1.482|
;;;3367   	}
;;;3368   }
0001e2  4770              BX       lr
;;;3369   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskDelete PROC
;;;743    
;;;744    	void vTaskDelete( TaskHandle_t xTaskToDelete )
0001e4  b570              PUSH     {r4-r6,lr}
;;;745    	{
0001e6  4605              MOV      r5,r0
;;;746    	TCB_t *pxTCB;
;;;747    
;;;748    		taskENTER_CRITICAL();
0001e8  f7fffffe          BL       vPortEnterCritical
;;;749    		{
;;;750    			/* If null is passed in here then it is the calling task that is
;;;751    			being deleted. */
;;;752    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
0001ec  b915              CBNZ     r5,|L1.500|
0001ee  488f              LDR      r0,|L1.1068|
0001f0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0001f2  e000              B        |L1.502|
                  |L1.500|
0001f4  4628              MOV      r0,r5
                  |L1.502|
0001f6  4604              MOV      r4,r0
;;;753    
;;;754    			/* Remove task from the ready list and place in the	termination list.
;;;755    			This will stop the task from be scheduled.  The idle task will check
;;;756    			the termination list and free up any memory allocated by the
;;;757    			scheduler for the TCB and stack. */
;;;758    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0001f8  1d20              ADDS     r0,r4,#4
0001fa  f7fffffe          BL       uxListRemove
0001fe  b970              CBNZ     r0,|L1.542|
;;;759    			{
;;;760    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000200  6ae0              LDR      r0,[r4,#0x2c]
000202  eb000080          ADD      r0,r0,r0,LSL #2
000206  4980              LDR      r1,|L1.1032|
000208  f8510020          LDR      r0,[r1,r0,LSL #2]
00020c  b938              CBNZ     r0,|L1.542|
00020e  2001              MOVS     r0,#1
000210  6ae1              LDR      r1,[r4,#0x2c]
000212  4088              LSLS     r0,r0,r1
000214  4988              LDR      r1,|L1.1080|
000216  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000218  4381              BICS     r1,r1,r0
00021a  4887              LDR      r0,|L1.1080|
00021c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.542|
;;;761    			}
;;;762    			else
;;;763    			{
;;;764    				mtCOVERAGE_TEST_MARKER();
;;;765    			}
;;;766    
;;;767    			/* Is the task waiting on an event also? */
;;;768    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00021e  6aa0              LDR      r0,[r4,#0x28]
000220  b118              CBZ      r0,|L1.554|
;;;769    			{
;;;770    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000222  f1040018          ADD      r0,r4,#0x18
000226  f7fffffe          BL       uxListRemove
                  |L1.554|
;;;771    			}
;;;772    			else
;;;773    			{
;;;774    				mtCOVERAGE_TEST_MARKER();
;;;775    			}
;;;776    
;;;777    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
00022a  1d21              ADDS     r1,r4,#4
00022c  487a              LDR      r0,|L1.1048|
00022e  f7fffffe          BL       vListInsertEnd
;;;778    
;;;779    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;780    			there is a task that has been deleted and that it should therefore
;;;781    			check the xTasksWaitingTermination list. */
;;;782    			++uxTasksDeleted;
000232  4883              LDR      r0,|L1.1088|
000234  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
000236  1c40              ADDS     r0,r0,#1
000238  4981              LDR      r1,|L1.1088|
00023a  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;783    
;;;784    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;785    			can detect that the task lists need re-generating. */
;;;786    			uxTaskNumber++;
00023c  487d              LDR      r0,|L1.1076|
00023e  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000240  1c40              ADDS     r0,r0,#1
000242  497c              LDR      r1,|L1.1076|
000244  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;787    
;;;788    			traceTASK_DELETE( pxTCB );
;;;789    		}
;;;790    		taskEXIT_CRITICAL();
000246  f7fffffe          BL       vPortExitCritical
;;;791    
;;;792    		/* Force a reschedule if it is the currently running task that has just
;;;793    		been deleted. */
;;;794    		if( xSchedulerRunning != pdFALSE )
00024a  4879              LDR      r0,|L1.1072|
00024c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00024e  b160              CBZ      r0,|L1.618|
;;;795    		{
;;;796    			if( pxTCB == pxCurrentTCB )
000250  4876              LDR      r0,|L1.1068|
000252  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000254  4284              CMP      r4,r0
000256  d102              BNE      |L1.606|
;;;797    			{
;;;798    				configASSERT( uxSchedulerSuspended == 0 );
;;;799    
;;;800    				/* The pre-delete hook is primarily for the Windows simulator,
;;;801    				in which Windows specific clean up operations are performed,
;;;802    				after which it is not possible to yield away from this task -
;;;803    				hence xYieldPending is used to latch that a context switch is
;;;804    				required. */
;;;805    				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;806    				portYIELD_WITHIN_API();
000258  f7fffffe          BL       vPortYield
00025c  e005              B        |L1.618|
                  |L1.606|
;;;807    			}
;;;808    			else
;;;809    			{
;;;810    				/* Reset the next expected unblock time in case it referred to
;;;811    				the task that has just been deleted. */
;;;812    				taskENTER_CRITICAL();
00025e  f7fffffe          BL       vPortEnterCritical
;;;813    				{
;;;814    					prvResetNextTaskUnblockTime();
000262  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;815    				}
;;;816    				taskEXIT_CRITICAL();
000266  f7fffffe          BL       vPortExitCritical
                  |L1.618|
;;;817    			}
;;;818    		}
;;;819    	}
00026a  bd70              POP      {r4-r6,pc}
;;;820    
                          ENDP

                  xTaskIncrementTick PROC
;;;1938   
;;;1939   BaseType_t xTaskIncrementTick( void )
00026c  e92d41f0          PUSH     {r4-r8,lr}
;;;1940   {
;;;1941   TCB_t * pxTCB;
;;;1942   TickType_t xItemValue;
;;;1943   BaseType_t xSwitchRequired = pdFALSE;
000270  2700              MOVS     r7,#0
;;;1944   
;;;1945   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1946   	Increments the tick then checks to see if the new tick value will cause any
;;;1947   	tasks to be unblocked. */
;;;1948   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1949   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000272  4874              LDR      r0,|L1.1092|
000274  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000276  bba8              CBNZ     r0,|L1.740|
;;;1950   	{
;;;1951   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1952   		delayed lists if it wraps to 0. */
;;;1953   		++xTickCount;
000278  4873              LDR      r0,|L1.1096|
00027a  6800              LDR      r0,[r0,#0]  ; xTickCount
00027c  1c40              ADDS     r0,r0,#1
00027e  4972              LDR      r1,|L1.1096|
000280  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1954   
;;;1955   		{
;;;1956   			/* Minor optimisation.  The tick count cannot change in this
;;;1957   			block. */
;;;1958   			const TickType_t xConstTickCount = xTickCount;
000282  4608              MOV      r0,r1
000284  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1959   
;;;1960   			if( xConstTickCount == ( TickType_t ) 0U )
000286  b98e              CBNZ     r6,|L1.684|
;;;1961   			{
;;;1962   				taskSWITCH_DELAYED_LISTS();
000288  4865              LDR      r0,|L1.1056|
00028a  f8d08000          LDR      r8,[r0,#0]  ; pxDelayedTaskList
00028e  4865              LDR      r0,|L1.1060|
000290  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000292  4963              LDR      r1,|L1.1056|
000294  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
000296  4863              LDR      r0,|L1.1060|
000298  f8c08000          STR      r8,[r0,#0]  ; pxOverflowDelayedTaskList
00029c  486b              LDR      r0,|L1.1100|
00029e  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
0002a0  1c40              ADDS     r0,r0,#1
0002a2  496a              LDR      r1,|L1.1100|
0002a4  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
0002a6  f7fffffe          BL       prvResetNextTaskUnblockTime
0002aa  bf00              NOP      
                  |L1.684|
;;;1963   			}
;;;1964   			else
;;;1965   			{
;;;1966   				mtCOVERAGE_TEST_MARKER();
;;;1967   			}
;;;1968   
;;;1969   			/* See if this tick has made a timeout expire.  Tasks are stored in
;;;1970   			the	queue in the order of their wake time - meaning once one task
;;;1971   			has been found whose block time has not expired there is no need to
;;;1972   			look any further down the list. */
;;;1973   			if( xConstTickCount >= xNextTaskUnblockTime )
0002ac  4863              LDR      r0,|L1.1084|
0002ae  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
0002b0  4286              CMP      r6,r0
0002b2  d33b              BCC      |L1.812|
;;;1974   			{
;;;1975   				for( ;; )
0002b4  bf00              NOP      
                  |L1.694|
;;;1976   				{
;;;1977   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0002b6  485a              LDR      r0,|L1.1056|
0002b8  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
0002ba  6800              LDR      r0,[r0,#0]
0002bc  b908              CBNZ     r0,|L1.706|
0002be  2001              MOVS     r0,#1
0002c0  e000              B        |L1.708|
                  |L1.706|
0002c2  2000              MOVS     r0,#0
                  |L1.708|
0002c4  b120              CBZ      r0,|L1.720|
;;;1978   					{
;;;1979   						/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;1980   						to the maximum possible value so it is extremely
;;;1981   						unlikely that the
;;;1982   						if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1983   						next time through. */
;;;1984   						xNextTaskUnblockTime = portMAX_DELAY;
0002c6  f04f30ff          MOV      r0,#0xffffffff
0002ca  495c              LDR      r1,|L1.1084|
0002cc  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1985   						break;
0002ce  e02c              B        |L1.810|
                  |L1.720|
;;;1986   					}
;;;1987   					else
;;;1988   					{
;;;1989   						/* The delayed list is not empty, get the value of the
;;;1990   						item at the head of the delayed list.  This is the time
;;;1991   						at which the task at the head of the delayed list must
;;;1992   						be removed from the Blocked state. */
;;;1993   						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0002d0  4853              LDR      r0,|L1.1056|
0002d2  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
0002d4  68c0              LDR      r0,[r0,#0xc]
0002d6  68c4              LDR      r4,[r0,#0xc]
;;;1994   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
0002d8  6865              LDR      r5,[r4,#4]
;;;1995   
;;;1996   						if( xConstTickCount < xItemValue )
0002da  42ae              CMP      r6,r5
0002dc  d203              BCS      |L1.742|
;;;1997   						{
;;;1998   							/* It is not time to unblock this item yet, but the
;;;1999   							item value is the time at which the task at the head
;;;2000   							of the blocked list must be removed from the Blocked
;;;2001   							state -	so record the item value in
;;;2002   							xNextTaskUnblockTime. */
;;;2003   							xNextTaskUnblockTime = xItemValue;
0002de  4857              LDR      r0,|L1.1084|
0002e0  6005              STR      r5,[r0,#0]  ; xNextTaskUnblockTime
;;;2004   							break;
0002e2  e022              B        |L1.810|
                  |L1.740|
0002e4  e02e              B        |L1.836|
                  |L1.742|
;;;2005   						}
;;;2006   						else
;;;2007   						{
;;;2008   							mtCOVERAGE_TEST_MARKER();
;;;2009   						}
;;;2010   
;;;2011   						/* It is time to remove the item from the Blocked state. */
;;;2012   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
0002e6  1d20              ADDS     r0,r4,#4
0002e8  f7fffffe          BL       uxListRemove
;;;2013   
;;;2014   						/* Is the task waiting on an event also?  If so remove
;;;2015   						it from the event list. */
;;;2016   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0002ec  6aa0              LDR      r0,[r4,#0x28]
0002ee  b118              CBZ      r0,|L1.760|
;;;2017   						{
;;;2018   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0002f0  f1040018          ADD      r0,r4,#0x18
0002f4  f7fffffe          BL       uxListRemove
                  |L1.760|
;;;2019   						}
;;;2020   						else
;;;2021   						{
;;;2022   							mtCOVERAGE_TEST_MARKER();
;;;2023   						}
;;;2024   
;;;2025   						/* Place the unblocked task into the appropriate ready
;;;2026   						list. */
;;;2027   						prvAddTaskToReadyList( pxTCB );
0002f8  2001              MOVS     r0,#1
0002fa  6ae1              LDR      r1,[r4,#0x2c]
0002fc  4088              LSLS     r0,r0,r1
0002fe  494e              LDR      r1,|L1.1080|
000300  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000302  4308              ORRS     r0,r0,r1
000304  494c              LDR      r1,|L1.1080|
000306  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000308  6ae1              LDR      r1,[r4,#0x2c]
00030a  eb010181          ADD      r1,r1,r1,LSL #2
00030e  4a3e              LDR      r2,|L1.1032|
000310  eb020081          ADD      r0,r2,r1,LSL #2
000314  1d21              ADDS     r1,r4,#4
000316  f7fffffe          BL       vListInsertEnd
;;;2028   
;;;2029   						/* A task being unblocked cannot cause an immediate
;;;2030   						context switch if preemption is turned off. */
;;;2031   						#if (  configUSE_PREEMPTION == 1 )
;;;2032   						{
;;;2033   							/* Preemption is on, but a context switch should
;;;2034   							only be performed if the unblocked task has a
;;;2035   							priority that is equal to or higher than the
;;;2036   							currently executing task. */
;;;2037   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00031a  4944              LDR      r1,|L1.1068|
00031c  6ae0              LDR      r0,[r4,#0x2c]
00031e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000320  6ac9              LDR      r1,[r1,#0x2c]
000322  4288              CMP      r0,r1
000324  d3c7              BCC      |L1.694|
;;;2038   							{
;;;2039   								xSwitchRequired = pdTRUE;
000326  2701              MOVS     r7,#1
000328  e7c5              B        |L1.694|
                  |L1.810|
00032a  bf00              NOP                            ;1985
                  |L1.812|
;;;2040   							}
;;;2041   							else
;;;2042   							{
;;;2043   								mtCOVERAGE_TEST_MARKER();
;;;2044   							}
;;;2045   						}
;;;2046   						#endif /* configUSE_PREEMPTION */
;;;2047   					}
;;;2048   				}
;;;2049   			}
;;;2050   		}
;;;2051   
;;;2052   		/* Tasks of equal priority to the currently running task will share
;;;2053   		processing time (time slice) if preemption is on, and the application
;;;2054   		writer has not explicitly turned time slicing off. */
;;;2055   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2056   		{
;;;2057   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
00032c  483f              LDR      r0,|L1.1068|
00032e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000330  6ac0              LDR      r0,[r0,#0x2c]
000332  eb000080          ADD      r0,r0,r0,LSL #2
000336  4934              LDR      r1,|L1.1032|
000338  f8510020          LDR      r0,[r1,r0,LSL #2]
00033c  2801              CMP      r0,#1
00033e  d906              BLS      |L1.846|
;;;2058   			{
;;;2059   				xSwitchRequired = pdTRUE;
000340  2701              MOVS     r7,#1
000342  e004              B        |L1.846|
                  |L1.836|
;;;2060   			}
;;;2061   			else
;;;2062   			{
;;;2063   				mtCOVERAGE_TEST_MARKER();
;;;2064   			}
;;;2065   		}
;;;2066   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2067   
;;;2068   		#if ( configUSE_TICK_HOOK == 1 )
;;;2069   		{
;;;2070   			/* Guard against the tick hook being called when the pended tick
;;;2071   			count is being unwound (when the scheduler is being unlocked). */
;;;2072   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2073   			{
;;;2074   				vApplicationTickHook();
;;;2075   			}
;;;2076   			else
;;;2077   			{
;;;2078   				mtCOVERAGE_TEST_MARKER();
;;;2079   			}
;;;2080   		}
;;;2081   		#endif /* configUSE_TICK_HOOK */
;;;2082   	}
;;;2083   	else
;;;2084   	{
;;;2085   		++uxPendedTicks;
000344  4842              LDR      r0,|L1.1104|
000346  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
000348  1c40              ADDS     r0,r0,#1
00034a  4941              LDR      r1,|L1.1104|
00034c  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L1.846|
;;;2086   
;;;2087   		/* The tick hook gets called at regular intervals, even if the
;;;2088   		scheduler is locked. */
;;;2089   		#if ( configUSE_TICK_HOOK == 1 )
;;;2090   		{
;;;2091   			vApplicationTickHook();
;;;2092   		}
;;;2093   		#endif
;;;2094   	}
;;;2095   
;;;2096   	#if ( configUSE_PREEMPTION == 1 )
;;;2097   	{
;;;2098   		if( xYieldPending != pdFALSE )
00034e  4841              LDR      r0,|L1.1108|
000350  6800              LDR      r0,[r0,#0]  ; xYieldPending
000352  b100              CBZ      r0,|L1.854|
;;;2099   		{
;;;2100   			xSwitchRequired = pdTRUE;
000354  2701              MOVS     r7,#1
                  |L1.854|
;;;2101   		}
;;;2102   		else
;;;2103   		{
;;;2104   			mtCOVERAGE_TEST_MARKER();
;;;2105   		}
;;;2106   	}
;;;2107   	#endif /* configUSE_PREEMPTION */
;;;2108   
;;;2109   	return xSwitchRequired;
000356  4638              MOV      r0,r7
;;;2110   }
000358  e8bd81f0          POP      {r4-r8,pc}
;;;2111   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;1670   
;;;1671   BaseType_t xTaskResumeAll( void )
00035c  b570              PUSH     {r4-r6,lr}
;;;1672   {
;;;1673   TCB_t *pxTCB;
;;;1674   BaseType_t xAlreadyYielded = pdFALSE;
00035e  2500              MOVS     r5,#0
;;;1675   
;;;1676   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1677   	previous call to vTaskSuspendAll(). */
;;;1678   	configASSERT( uxSchedulerSuspended );
;;;1679   
;;;1680   	/* It is possible that an ISR caused a task to be removed from an event
;;;1681   	list while the scheduler was suspended.  If this was the case then the
;;;1682   	removed task will have been added to the xPendingReadyList.  Once the
;;;1683   	scheduler has been resumed it is safe to move all the pending ready
;;;1684   	tasks from this list into their appropriate ready list. */
;;;1685   	taskENTER_CRITICAL();
000360  f7fffffe          BL       vPortEnterCritical
;;;1686   	{
;;;1687   		--uxSchedulerSuspended;
000364  4837              LDR      r0,|L1.1092|
000366  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000368  1e40              SUBS     r0,r0,#1
00036a  4936              LDR      r1,|L1.1092|
00036c  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1688   
;;;1689   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00036e  4608              MOV      r0,r1
000370  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000372  bb98              CBNZ     r0,|L1.988|
;;;1690   		{
;;;1691   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000374  482c              LDR      r0,|L1.1064|
000376  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000378  b380              CBZ      r0,|L1.988|
;;;1692   			{
;;;1693   				/* Move any readied tasks from the pending list into the
;;;1694   				appropriate ready list. */
;;;1695   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
00037a  e023              B        |L1.964|
                  |L1.892|
;;;1696   				{
;;;1697   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
00037c  4825              LDR      r0,|L1.1044|
00037e  68c0              LDR      r0,[r0,#0xc]
000380  68c4              LDR      r4,[r0,#0xc]
;;;1698   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000382  f1040018          ADD      r0,r4,#0x18
000386  f7fffffe          BL       uxListRemove
;;;1699   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
00038a  1d20              ADDS     r0,r4,#4
00038c  f7fffffe          BL       uxListRemove
;;;1700   					prvAddTaskToReadyList( pxTCB );
000390  2001              MOVS     r0,#1
000392  6ae1              LDR      r1,[r4,#0x2c]
000394  4088              LSLS     r0,r0,r1
000396  4928              LDR      r1,|L1.1080|
000398  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00039a  4308              ORRS     r0,r0,r1
00039c  4926              LDR      r1,|L1.1080|
00039e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0003a0  6ae1              LDR      r1,[r4,#0x2c]
0003a2  eb010181          ADD      r1,r1,r1,LSL #2
0003a6  4a18              LDR      r2,|L1.1032|
0003a8  eb020081          ADD      r0,r2,r1,LSL #2
0003ac  1d21              ADDS     r1,r4,#4
0003ae  f7fffffe          BL       vListInsertEnd
;;;1701   
;;;1702   					/* If the moved task has a priority higher than the current
;;;1703   					task then a yield must be performed. */
;;;1704   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0003b2  491e              LDR      r1,|L1.1068|
0003b4  6ae0              LDR      r0,[r4,#0x2c]
0003b6  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0003b8  6ac9              LDR      r1,[r1,#0x2c]
0003ba  4288              CMP      r0,r1
0003bc  d302              BCC      |L1.964|
;;;1705   					{
;;;1706   						xYieldPending = pdTRUE;
0003be  2001              MOVS     r0,#1
0003c0  4924              LDR      r1,|L1.1108|
0003c2  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L1.964|
0003c4  4813              LDR      r0,|L1.1044|
0003c6  6800              LDR      r0,[r0,#0]            ;1695  ; xPendingReadyList
0003c8  b908              CBNZ     r0,|L1.974|
0003ca  2001              MOVS     r0,#1                 ;1695
0003cc  e000              B        |L1.976|
                  |L1.974|
0003ce  2000              MOVS     r0,#0                 ;1695
                  |L1.976|
0003d0  2800              CMP      r0,#0                 ;1695
0003d2  d0d3              BEQ      |L1.892|
;;;1707   					}
;;;1708   					else
;;;1709   					{
;;;1710   						mtCOVERAGE_TEST_MARKER();
;;;1711   					}
;;;1712   				}
;;;1713   
;;;1714   				/* If any ticks occurred while the scheduler was suspended then
;;;1715   				they should be processed now.  This ensures the tick count does
;;;1716   				not	slip, and that any delayed tasks are resumed at the correct
;;;1717   				time. */
;;;1718   				if( uxPendedTicks > ( UBaseType_t ) 0U )
0003d4  481e              LDR      r0,|L1.1104|
0003d6  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0003d8  b180              CBZ      r0,|L1.1020|
;;;1719   				{
;;;1720   					while( uxPendedTicks > ( UBaseType_t ) 0U )
0003da  e00b              B        |L1.1012|
                  |L1.988|
0003dc  e03e              B        |L1.1116|
                  |L1.990|
;;;1721   					{
;;;1722   						if( xTaskIncrementTick() != pdFALSE )
0003de  f7fffffe          BL       xTaskIncrementTick
0003e2  b110              CBZ      r0,|L1.1002|
;;;1723   						{
;;;1724   							xYieldPending = pdTRUE;
0003e4  2001              MOVS     r0,#1
0003e6  491b              LDR      r1,|L1.1108|
0003e8  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L1.1002|
;;;1725   						}
;;;1726   						else
;;;1727   						{
;;;1728   							mtCOVERAGE_TEST_MARKER();
;;;1729   						}
;;;1730   						--uxPendedTicks;
0003ea  4819              LDR      r0,|L1.1104|
0003ec  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0003ee  1e40              SUBS     r0,r0,#1
0003f0  4917              LDR      r1,|L1.1104|
0003f2  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L1.1012|
0003f4  4816              LDR      r0,|L1.1104|
0003f6  6800              LDR      r0,[r0,#0]            ;1720  ; uxPendedTicks
0003f8  2800              CMP      r0,#0                 ;1720
0003fa  d1f0              BNE      |L1.990|
                  |L1.1020|
;;;1731   					}
;;;1732   				}
;;;1733   				else
;;;1734   				{
;;;1735   					mtCOVERAGE_TEST_MARKER();
;;;1736   				}
;;;1737   
;;;1738   				if( xYieldPending == pdTRUE )
0003fc  4815              LDR      r0,|L1.1108|
0003fe  6800              LDR      r0,[r0,#0]  ; xYieldPending
000400  2801              CMP      r0,#1
000402  d12b              BNE      |L1.1116|
;;;1739   				{
;;;1740   					#if( configUSE_PREEMPTION != 0 )
;;;1741   					{
;;;1742   						xAlreadyYielded = pdTRUE;
000404  2501              MOVS     r5,#1
;;;1743   					}
;;;1744   					#endif
;;;1745   					taskYIELD_IF_USING_PREEMPTION();
000406  e027              B        |L1.1112|
                  |L1.1032|
                          DCD      pxReadyTasksLists
                  |L1.1036|
                          DCD      xDelayedTaskList1
                  |L1.1040|
                          DCD      xDelayedTaskList2
                  |L1.1044|
                          DCD      xPendingReadyList
                  |L1.1048|
                          DCD      xTasksWaitingTermination
                  |L1.1052|
                          DCD      xSuspendedTaskList
                  |L1.1056|
                          DCD      pxDelayedTaskList
                  |L1.1060|
                          DCD      pxOverflowDelayedTaskList
                  |L1.1064|
                          DCD      uxCurrentNumberOfTasks
                  |L1.1068|
                          DCD      pxCurrentTCB
                  |L1.1072|
                          DCD      xSchedulerRunning
                  |L1.1076|
                          DCD      uxTaskNumber
                  |L1.1080|
                          DCD      uxTopReadyPriority
                  |L1.1084|
                          DCD      xNextTaskUnblockTime
                  |L1.1088|
                          DCD      uxTasksDeleted
                  |L1.1092|
                          DCD      uxSchedulerSuspended
                  |L1.1096|
                          DCD      xTickCount
                  |L1.1100|
                          DCD      xNumOfOverflows
                  |L1.1104|
                          DCD      uxPendedTicks
                  |L1.1108|
                          DCD      xYieldPending
                  |L1.1112|
000458  f7fffffe          BL       vPortYield
                  |L1.1116|
;;;1746   				}
;;;1747   				else
;;;1748   				{
;;;1749   					mtCOVERAGE_TEST_MARKER();
;;;1750   				}
;;;1751   			}
;;;1752   		}
;;;1753   		else
;;;1754   		{
;;;1755   			mtCOVERAGE_TEST_MARKER();
;;;1756   		}
;;;1757   	}
;;;1758   	taskEXIT_CRITICAL();
00045c  f7fffffe          BL       vPortExitCritical
;;;1759   
;;;1760   	return xAlreadyYielded;
000460  4628              MOV      r0,r5
;;;1761   }
000462  bd70              POP      {r4-r6,pc}
;;;1762   /*-----------------------------------------------------------*/
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;3070   
;;;3071   static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
000464  b510              PUSH     {r4,lr}
;;;3072   {
000466  4604              MOV      r4,r0
;;;3073   	/* The list item will be inserted in wake time order. */
;;;3074   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000468  48f8              LDR      r0,|L1.2124|
00046a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00046c  6044              STR      r4,[r0,#4]
;;;3075   
;;;3076   	if( xTimeToWake < xTickCount )
00046e  48f8              LDR      r0,|L1.2128|
000470  6800              LDR      r0,[r0,#0]  ; xTickCount
000472  4284              CMP      r4,r0
000474  d207              BCS      |L1.1158|
;;;3077   	{
;;;3078   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;3079   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000476  48f5              LDR      r0,|L1.2124|
000478  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00047a  1d09              ADDS     r1,r1,#4
00047c  48f5              LDR      r0,|L1.2132|
00047e  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000480  f7fffffe          BL       vListInsert
000484  e00c              B        |L1.1184|
                  |L1.1158|
;;;3080   	}
;;;3081   	else
;;;3082   	{
;;;3083   		/* The wake time has not overflowed, so the current block list is used. */
;;;3084   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000486  48f1              LDR      r0,|L1.2124|
000488  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00048a  1d09              ADDS     r1,r1,#4
00048c  48f2              LDR      r0,|L1.2136|
00048e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000490  f7fffffe          BL       vListInsert
;;;3085   
;;;3086   		/* If the task entering the blocked state was placed at the head of the
;;;3087   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;3088   		too. */
;;;3089   		if( xTimeToWake < xNextTaskUnblockTime )
000494  48f1              LDR      r0,|L1.2140|
000496  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000498  4284              CMP      r4,r0
00049a  d201              BCS      |L1.1184|
;;;3090   		{
;;;3091   			xNextTaskUnblockTime = xTimeToWake;
00049c  48ef              LDR      r0,|L1.2140|
00049e  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L1.1184|
;;;3092   		}
;;;3093   		else
;;;3094   		{
;;;3095   			mtCOVERAGE_TEST_MARKER();
;;;3096   		}
;;;3097   	}
;;;3098   }
0004a0  bd10              POP      {r4,pc}
;;;3099   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspendAll PROC
;;;1632   
;;;1633   void vTaskSuspendAll( void )
0004a2  48ef              LDR      r0,|L1.2144|
;;;1634   {
;;;1635   	/* A critical section is not required as the variable is of type
;;;1636   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1637   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1638   	http://goo.gl/wu4acr */
;;;1639   	++uxSchedulerSuspended;
0004a4  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0004a6  1c40              ADDS     r0,r0,#1
0004a8  49ed              LDR      r1,|L1.2144|
0004aa  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1640   }
0004ac  4770              BX       lr
;;;1641   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;825    
;;;826    	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
0004ae  e92d47f0          PUSH     {r4-r10,lr}
;;;827    	{
0004b2  4604              MOV      r4,r0
0004b4  4688              MOV      r8,r1
;;;828    	TickType_t xTimeToWake;
;;;829    	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
0004b6  f04f0900          MOV      r9,#0
;;;830    
;;;831    		configASSERT( pxPreviousWakeTime );
;;;832    		configASSERT( ( xTimeIncrement > 0U ) );
;;;833    		configASSERT( uxSchedulerSuspended == 0 );
;;;834    
;;;835    		vTaskSuspendAll();
0004ba  f7fffffe          BL       vTaskSuspendAll
;;;836    		{
;;;837    			/* Minor optimisation.  The tick count cannot change in this
;;;838    			block. */
;;;839    			const TickType_t xConstTickCount = xTickCount;
0004be  48e4              LDR      r0,|L1.2128|
0004c0  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;840    
;;;841    			/* Generate the tick time at which the task wants to wake. */
;;;842    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
0004c2  6820              LDR      r0,[r4,#0]
0004c4  eb000508          ADD      r5,r0,r8
;;;843    
;;;844    			if( xConstTickCount < *pxPreviousWakeTime )
0004c8  6820              LDR      r0,[r4,#0]
0004ca  42b8              CMP      r0,r7
0004cc  d907              BLS      |L1.1246|
;;;845    			{
;;;846    				/* The tick count has overflowed since this function was
;;;847    				lasted called.  In this case the only time we should ever
;;;848    				actually delay is if the wake time has also	overflowed,
;;;849    				and the wake time is greater than the tick time.  When this
;;;850    				is the case it is as if neither time had overflowed. */
;;;851    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0004ce  6820              LDR      r0,[r4,#0]
0004d0  42a8              CMP      r0,r5
0004d2  d90b              BLS      |L1.1260|
0004d4  42bd              CMP      r5,r7
0004d6  d909              BLS      |L1.1260|
;;;852    				{
;;;853    					xShouldDelay = pdTRUE;
0004d8  f04f0901          MOV      r9,#1
0004dc  e006              B        |L1.1260|
                  |L1.1246|
;;;854    				}
;;;855    				else
;;;856    				{
;;;857    					mtCOVERAGE_TEST_MARKER();
;;;858    				}
;;;859    			}
;;;860    			else
;;;861    			{
;;;862    				/* The tick time has not overflowed.  In this case we will
;;;863    				delay if either the wake time has overflowed, and/or the
;;;864    				tick time is less than the wake time. */
;;;865    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0004de  6820              LDR      r0,[r4,#0]
0004e0  42a8              CMP      r0,r5
0004e2  d801              BHI      |L1.1256|
0004e4  42bd              CMP      r5,r7
0004e6  d901              BLS      |L1.1260|
                  |L1.1256|
;;;866    				{
;;;867    					xShouldDelay = pdTRUE;
0004e8  f04f0901          MOV      r9,#1
                  |L1.1260|
;;;868    				}
;;;869    				else
;;;870    				{
;;;871    					mtCOVERAGE_TEST_MARKER();
;;;872    				}
;;;873    			}
;;;874    
;;;875    			/* Update the wake time ready for the next call. */
;;;876    			*pxPreviousWakeTime = xTimeToWake;
0004ec  6025              STR      r5,[r4,#0]
;;;877    
;;;878    			if( xShouldDelay != pdFALSE )
0004ee  f1b90f00          CMP      r9,#0
0004f2  d012              BEQ      |L1.1306|
;;;879    			{
;;;880    				traceTASK_DELAY_UNTIL();
;;;881    
;;;882    				/* Remove the task from the ready list before adding it to the
;;;883    				blocked list as the same list item is used for both lists. */
;;;884    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0004f4  48d5              LDR      r0,|L1.2124|
0004f6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0004f8  1d00              ADDS     r0,r0,#4
0004fa  f7fffffe          BL       uxListRemove
0004fe  b948              CBNZ     r0,|L1.1300|
;;;885    				{
;;;886    					/* The current task must be in a ready list, so there is
;;;887    					no need to check, and the port reset macro can be called
;;;888    					directly. */
;;;889    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000500  48d2              LDR      r0,|L1.2124|
000502  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000504  6ac1              LDR      r1,[r0,#0x2c]
000506  2001              MOVS     r0,#1
000508  4088              LSLS     r0,r0,r1
00050a  49d6              LDR      r1,|L1.2148|
00050c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00050e  4381              BICS     r1,r1,r0
000510  48d4              LDR      r0,|L1.2148|
000512  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1300|
;;;890    				}
;;;891    				else
;;;892    				{
;;;893    					mtCOVERAGE_TEST_MARKER();
;;;894    				}
;;;895    
;;;896    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000514  4628              MOV      r0,r5
000516  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.1306|
;;;897    			}
;;;898    			else
;;;899    			{
;;;900    				mtCOVERAGE_TEST_MARKER();
;;;901    			}
;;;902    		}
;;;903    		xAlreadyYielded = xTaskResumeAll();
00051a  f7fffffe          BL       xTaskResumeAll
00051e  4606              MOV      r6,r0
;;;904    
;;;905    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;906    		have put ourselves to sleep. */
;;;907    		if( xAlreadyYielded == pdFALSE )
000520  b90e              CBNZ     r6,|L1.1318|
;;;908    		{
;;;909    			portYIELD_WITHIN_API();
000522  f7fffffe          BL       vPortYield
                  |L1.1318|
;;;910    		}
;;;911    		else
;;;912    		{
;;;913    			mtCOVERAGE_TEST_MARKER();
;;;914    		}
;;;915    	}
000526  e8bd87f0          POP      {r4-r10,pc}
;;;916    
                          ENDP

                  vTaskDelay PROC
;;;921    
;;;922    	void vTaskDelay( const TickType_t xTicksToDelay )
00052a  b570              PUSH     {r4-r6,lr}
;;;923    	{
00052c  4604              MOV      r4,r0
;;;924    	TickType_t xTimeToWake;
;;;925    	BaseType_t xAlreadyYielded = pdFALSE;
00052e  2600              MOVS     r6,#0
;;;926    
;;;927    
;;;928    		/* A delay time of zero just forces a reschedule. */
;;;929    		if( xTicksToDelay > ( TickType_t ) 0U )
000530  b1d4              CBZ      r4,|L1.1384|
;;;930    		{
;;;931    			configASSERT( uxSchedulerSuspended == 0 );
;;;932    			vTaskSuspendAll();
000532  f7fffffe          BL       vTaskSuspendAll
;;;933    			{
;;;934    				traceTASK_DELAY();
;;;935    
;;;936    				/* A task that is removed from the event list while the
;;;937    				scheduler is suspended will not get placed in the ready
;;;938    				list or removed from the blocked list until the scheduler
;;;939    				is resumed.
;;;940    
;;;941    				This task cannot be in an event list as it is the currently
;;;942    				executing task. */
;;;943    
;;;944    				/* Calculate the time to wake - this may overflow but this is
;;;945    				not a problem. */
;;;946    				xTimeToWake = xTickCount + xTicksToDelay;
000536  48c6              LDR      r0,|L1.2128|
000538  6800              LDR      r0,[r0,#0]  ; xTickCount
00053a  1905              ADDS     r5,r0,r4
;;;947    
;;;948    				/* We must remove ourselves from the ready list before adding
;;;949    				ourselves to the blocked list as the same list item is used for
;;;950    				both lists. */
;;;951    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00053c  48c3              LDR      r0,|L1.2124|
00053e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000540  1d00              ADDS     r0,r0,#4
000542  f7fffffe          BL       uxListRemove
000546  b948              CBNZ     r0,|L1.1372|
;;;952    				{
;;;953    					/* The current task must be in a ready list, so there is
;;;954    					no need to check, and the port reset macro can be called
;;;955    					directly. */
;;;956    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000548  48c0              LDR      r0,|L1.2124|
00054a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00054c  6ac1              LDR      r1,[r0,#0x2c]
00054e  2001              MOVS     r0,#1
000550  4088              LSLS     r0,r0,r1
000552  49c4              LDR      r1,|L1.2148|
000554  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000556  4381              BICS     r1,r1,r0
000558  48c2              LDR      r0,|L1.2148|
00055a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1372|
;;;957    				}
;;;958    				else
;;;959    				{
;;;960    					mtCOVERAGE_TEST_MARKER();
;;;961    				}
;;;962    				prvAddCurrentTaskToDelayedList( xTimeToWake );
00055c  4628              MOV      r0,r5
00055e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;963    			}
;;;964    			xAlreadyYielded = xTaskResumeAll();
000562  f7fffffe          BL       xTaskResumeAll
000566  4606              MOV      r6,r0
                  |L1.1384|
;;;965    		}
;;;966    		else
;;;967    		{
;;;968    			mtCOVERAGE_TEST_MARKER();
;;;969    		}
;;;970    
;;;971    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;972    		have put ourselves to sleep. */
;;;973    		if( xAlreadyYielded == pdFALSE )
000568  b90e              CBNZ     r6,|L1.1390|
;;;974    		{
;;;975    			portYIELD_WITHIN_API();
00056a  f7fffffe          BL       vPortYield
                  |L1.1390|
;;;976    		}
;;;977    		else
;;;978    		{
;;;979    			mtCOVERAGE_TEST_MARKER();
;;;980    		}
;;;981    	}
00056e  bd70              POP      {r4-r6,pc}
;;;982    
                          ENDP

                  uxTaskPriorityGet PROC
;;;1057   
;;;1058   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000570  b570              PUSH     {r4-r6,lr}
;;;1059   	{
000572  4604              MOV      r4,r0
;;;1060   	TCB_t *pxTCB;
;;;1061   	UBaseType_t uxReturn;
;;;1062   
;;;1063   		taskENTER_CRITICAL();
000574  f7fffffe          BL       vPortEnterCritical
;;;1064   		{
;;;1065   			/* If null is passed in here then it is the priority of the that
;;;1066   			called uxTaskPriorityGet() that is being queried. */
;;;1067   			pxTCB = prvGetTCBFromHandle( xTask );
000578  b914              CBNZ     r4,|L1.1408|
00057a  48b4              LDR      r0,|L1.2124|
00057c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00057e  e000              B        |L1.1410|
                  |L1.1408|
000580  4620              MOV      r0,r4
                  |L1.1410|
000582  4606              MOV      r6,r0
;;;1068   			uxReturn = pxTCB->uxPriority;
000584  6af5              LDR      r5,[r6,#0x2c]
;;;1069   		}
;;;1070   		taskEXIT_CRITICAL();
000586  f7fffffe          BL       vPortExitCritical
;;;1071   
;;;1072   		return uxReturn;
00058a  4628              MOV      r0,r5
;;;1073   	}
00058c  bd70              POP      {r4-r6,pc}
;;;1074   
                          ENDP

                  uxTaskPriorityGetFromISR PROC
;;;1079   
;;;1080   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
00058e  e92d41f0          PUSH     {r4-r8,lr}
;;;1081   	{
000592  4604              MOV      r4,r0
;;;1082   	TCB_t *pxTCB;
;;;1083   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1084   
;;;1085   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1086   		maximum	system call (or maximum API call) interrupt priority.
;;;1087   		Interrupts that are	above the maximum system call priority are keep
;;;1088   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1089   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1090   		is defined in FreeRTOSConfig.h then
;;;1091   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1092   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1093   		been assigned a priority above the configured maximum system call
;;;1094   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1095   		from interrupts	that have been assigned a priority at or (logically)
;;;1096   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1097   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1098   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1099   		provided on the following link:
;;;1100   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1101   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1102   
;;;1103   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000594  f7fffffe          BL       ulPortSetInterruptMask
000598  4606              MOV      r6,r0
;;;1104   		{
;;;1105   			/* If null is passed in here then it is the priority of the calling
;;;1106   			task that is being queried. */
;;;1107   			pxTCB = prvGetTCBFromHandle( xTask );
00059a  b914              CBNZ     r4,|L1.1442|
00059c  48ab              LDR      r0,|L1.2124|
00059e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0005a0  e000              B        |L1.1444|
                  |L1.1442|
0005a2  4620              MOV      r0,r4
                  |L1.1444|
0005a4  4607              MOV      r7,r0
;;;1108   			uxReturn = pxTCB->uxPriority;
0005a6  6afd              LDR      r5,[r7,#0x2c]
;;;1109   		}
;;;1110   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
0005a8  4630              MOV      r0,r6
0005aa  f7fffffe          BL       vPortClearInterruptMask
;;;1111   
;;;1112   		return uxReturn;
0005ae  4628              MOV      r0,r5
;;;1113   	}
0005b0  e8bd81f0          POP      {r4-r8,pc}
;;;1114   
                          ENDP

                  vTaskPrioritySet PROC
;;;1119   
;;;1120   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
0005b4  e92d47f0          PUSH     {r4-r10,lr}
;;;1121   	{
0005b8  4680              MOV      r8,r0
0005ba  460d              MOV      r5,r1
;;;1122   	TCB_t *pxTCB;
;;;1123   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1124   	BaseType_t xYieldRequired = pdFALSE;
0005bc  f04f0900          MOV      r9,#0
;;;1125   
;;;1126   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;1127   
;;;1128   		/* Ensure the new priority is valid. */
;;;1129   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
0005c0  2d05              CMP      r5,#5
0005c2  d300              BCC      |L1.1478|
;;;1130   		{
;;;1131   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
0005c4  2504              MOVS     r5,#4
                  |L1.1478|
;;;1132   		}
;;;1133   		else
;;;1134   		{
;;;1135   			mtCOVERAGE_TEST_MARKER();
;;;1136   		}
;;;1137   
;;;1138   		taskENTER_CRITICAL();
0005c6  f7fffffe          BL       vPortEnterCritical
;;;1139   		{
;;;1140   			/* If null is passed in here then it is the priority of the calling
;;;1141   			task that is being changed. */
;;;1142   			pxTCB = prvGetTCBFromHandle( xTask );
0005ca  f1b80f00          CMP      r8,#0
0005ce  d102              BNE      |L1.1494|
0005d0  489e              LDR      r0,|L1.2124|
0005d2  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0005d4  e000              B        |L1.1496|
                  |L1.1494|
0005d6  4640              MOV      r0,r8
                  |L1.1496|
0005d8  4604              MOV      r4,r0
;;;1143   
;;;1144   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1145   
;;;1146   			#if ( configUSE_MUTEXES == 1 )
;;;1147   			{
;;;1148   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1149   			}
;;;1150   			#else
;;;1151   			{
;;;1152   				uxCurrentBasePriority = pxTCB->uxPriority;
0005da  6ae6              LDR      r6,[r4,#0x2c]
;;;1153   			}
;;;1154   			#endif
;;;1155   
;;;1156   			if( uxCurrentBasePriority != uxNewPriority )
0005dc  42ae              CMP      r6,r5
0005de  d04a              BEQ      |L1.1654|
;;;1157   			{
;;;1158   				/* The priority change may have readied a task of higher
;;;1159   				priority than the calling task. */
;;;1160   				if( uxNewPriority > uxCurrentBasePriority )
0005e0  42b5              CMP      r5,r6
0005e2  d90b              BLS      |L1.1532|
;;;1161   				{
;;;1162   					if( pxTCB != pxCurrentTCB )
0005e4  4899              LDR      r0,|L1.2124|
0005e6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0005e8  4284              CMP      r4,r0
0005ea  d00d              BEQ      |L1.1544|
;;;1163   					{
;;;1164   						/* The priority of a task other than the currently
;;;1165   						running task is being raised.  Is the priority being
;;;1166   						raised above that of the running task? */
;;;1167   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
0005ec  4897              LDR      r0,|L1.2124|
0005ee  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0005f0  6ac0              LDR      r0,[r0,#0x2c]
0005f2  42a8              CMP      r0,r5
0005f4  d808              BHI      |L1.1544|
;;;1168   						{
;;;1169   							xYieldRequired = pdTRUE;
0005f6  f04f0901          MOV      r9,#1
0005fa  e005              B        |L1.1544|
                  |L1.1532|
;;;1170   						}
;;;1171   						else
;;;1172   						{
;;;1173   							mtCOVERAGE_TEST_MARKER();
;;;1174   						}
;;;1175   					}
;;;1176   					else
;;;1177   					{
;;;1178   						/* The priority of the running task is being raised,
;;;1179   						but the running task must already be the highest
;;;1180   						priority task able to run so no yield is required. */
;;;1181   					}
;;;1182   				}
;;;1183   				else if( pxTCB == pxCurrentTCB )
0005fc  4893              LDR      r0,|L1.2124|
0005fe  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000600  4284              CMP      r4,r0
000602  d101              BNE      |L1.1544|
;;;1184   				{
;;;1185   					/* Setting the priority of the running task down means
;;;1186   					there may now be another task of higher priority that
;;;1187   					is ready to execute. */
;;;1188   					xYieldRequired = pdTRUE;
000604  f04f0901          MOV      r9,#1
                  |L1.1544|
;;;1189   				}
;;;1190   				else
;;;1191   				{
;;;1192   					/* Setting the priority of any other task down does not
;;;1193   					require a yield as the running task must be above the
;;;1194   					new priority of the task being modified. */
;;;1195   				}
;;;1196   
;;;1197   				/* Remember the ready list the task might be referenced from
;;;1198   				before its uxPriority member is changed so the
;;;1199   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1200   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000608  6ae7              LDR      r7,[r4,#0x2c]
;;;1201   
;;;1202   				#if ( configUSE_MUTEXES == 1 )
;;;1203   				{
;;;1204   					/* Only change the priority being used if the task is not
;;;1205   					currently using an inherited priority. */
;;;1206   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
;;;1207   					{
;;;1208   						pxTCB->uxPriority = uxNewPriority;
;;;1209   					}
;;;1210   					else
;;;1211   					{
;;;1212   						mtCOVERAGE_TEST_MARKER();
;;;1213   					}
;;;1214   
;;;1215   					/* The base priority gets set whatever. */
;;;1216   					pxTCB->uxBasePriority = uxNewPriority;
;;;1217   				}
;;;1218   				#else
;;;1219   				{
;;;1220   					pxTCB->uxPriority = uxNewPriority;
00060a  62e5              STR      r5,[r4,#0x2c]
;;;1221   				}
;;;1222   				#endif
;;;1223   
;;;1224   				/* Only reset the event list item value if the value is not
;;;1225   				being used for anything else. */
;;;1226   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00060c  69a0              LDR      r0,[r4,#0x18]
00060e  f0104f00          TST      r0,#0x80000000
000612  d102              BNE      |L1.1562|
;;;1227   				{
;;;1228   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000614  f1c50005          RSB      r0,r5,#5
000618  61a0              STR      r0,[r4,#0x18]
                  |L1.1562|
;;;1229   				}
;;;1230   				else
;;;1231   				{
;;;1232   					mtCOVERAGE_TEST_MARKER();
;;;1233   				}
;;;1234   
;;;1235   				/* If the task is in the blocked or suspended list we need do
;;;1236   				nothing more than change it's priority variable. However, if
;;;1237   				the task is in a ready list it needs to be removed and placed
;;;1238   				in the list appropriate to its new priority. */
;;;1239   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
00061a  eb070187          ADD      r1,r7,r7,LSL #2
00061e  4a92              LDR      r2,|L1.2152|
000620  eb020181          ADD      r1,r2,r1,LSL #2
000624  6960              LDR      r0,[r4,#0x14]
000626  4288              CMP      r0,r1
000628  d101              BNE      |L1.1582|
00062a  2001              MOVS     r0,#1
00062c  e000              B        |L1.1584|
                  |L1.1582|
00062e  2000              MOVS     r0,#0
                  |L1.1584|
000630  b1d8              CBZ      r0,|L1.1642|
;;;1240   				{
;;;1241   					/* The task is currently in its ready list - remove before adding
;;;1242   					it to it's new ready list.  As we are in a critical section we
;;;1243   					can do this even if the scheduler is suspended. */
;;;1244   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000632  1d20              ADDS     r0,r4,#4
000634  f7fffffe          BL       uxListRemove
000638  b930              CBNZ     r0,|L1.1608|
;;;1245   					{
;;;1246   						/* It is known that the task is in its ready list so
;;;1247   						there is no need to check again and the port level
;;;1248   						reset macro can be called directly. */
;;;1249   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
00063a  2001              MOVS     r0,#1
00063c  40b8              LSLS     r0,r0,r7
00063e  4989              LDR      r1,|L1.2148|
000640  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000642  4381              BICS     r1,r1,r0
000644  4887              LDR      r0,|L1.2148|
000646  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1608|
;;;1250   					}
;;;1251   					else
;;;1252   					{
;;;1253   						mtCOVERAGE_TEST_MARKER();
;;;1254   					}
;;;1255   					prvAddTaskToReadyList( pxTCB );
000648  2001              MOVS     r0,#1
00064a  6ae1              LDR      r1,[r4,#0x2c]
00064c  4088              LSLS     r0,r0,r1
00064e  4985              LDR      r1,|L1.2148|
000650  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000652  4308              ORRS     r0,r0,r1
000654  4983              LDR      r1,|L1.2148|
000656  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000658  6ae1              LDR      r1,[r4,#0x2c]
00065a  eb010181          ADD      r1,r1,r1,LSL #2
00065e  4a82              LDR      r2,|L1.2152|
000660  eb020081          ADD      r0,r2,r1,LSL #2
000664  1d21              ADDS     r1,r4,#4
000666  f7fffffe          BL       vListInsertEnd
                  |L1.1642|
;;;1256   				}
;;;1257   				else
;;;1258   				{
;;;1259   					mtCOVERAGE_TEST_MARKER();
;;;1260   				}
;;;1261   
;;;1262   				if( xYieldRequired == pdTRUE )
00066a  f1b90f01          CMP      r9,#1
00066e  d101              BNE      |L1.1652|
;;;1263   				{
;;;1264   					taskYIELD_IF_USING_PREEMPTION();
000670  f7fffffe          BL       vPortYield
                  |L1.1652|
;;;1265   				}
;;;1266   				else
;;;1267   				{
;;;1268   					mtCOVERAGE_TEST_MARKER();
;;;1269   				}
;;;1270   
;;;1271   				/* Remove compiler warning about unused variables when the port
;;;1272   				optimised task selection is not being used. */
;;;1273   				( void ) uxPriorityUsedOnEntry;
000674  bf00              NOP      
                  |L1.1654|
;;;1274   			}
;;;1275   		}
;;;1276   		taskEXIT_CRITICAL();
000676  f7fffffe          BL       vPortExitCritical
;;;1277   	}
00067a  e8bd87f0          POP      {r4-r10,pc}
;;;1278   
                          ENDP

                  vTaskSwitchContext PROC
;;;2202   
;;;2203   void vTaskSwitchContext( void )
00067e  4878              LDR      r0,|L1.2144|
;;;2204   {
;;;2205   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000680  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000682  b118              CBZ      r0,|L1.1676|
;;;2206   	{
;;;2207   		/* The scheduler is currently suspended - do not allow a context
;;;2208   		switch. */
;;;2209   		xYieldPending = pdTRUE;
000684  2001              MOVS     r0,#1
000686  4979              LDR      r1,|L1.2156|
000688  6008              STR      r0,[r1,#0]  ; xYieldPending
00068a  e01d              B        |L1.1736|
                  |L1.1676|
;;;2210   	}
;;;2211   	else
;;;2212   	{
;;;2213   		xYieldPending = pdFALSE;
00068c  2000              MOVS     r0,#0
00068e  4977              LDR      r1,|L1.2156|
000690  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2214   		traceTASK_SWITCHED_OUT();
;;;2215   
;;;2216   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2217   		{
;;;2218   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2219   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2220   				#else
;;;2221   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2222   				#endif
;;;2223   
;;;2224   				/* Add the amount of time the task has been running to the
;;;2225   				accumulated	time so far.  The time the task started running was
;;;2226   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2227   				protection here	so count values are only valid until the timer
;;;2228   				overflows.  The guard against negative values is to protect
;;;2229   				against suspect run time stat counter implementations - which
;;;2230   				are provided by the application, not the kernel. */
;;;2231   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2232   				{
;;;2233   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2234   				}
;;;2235   				else
;;;2236   				{
;;;2237   					mtCOVERAGE_TEST_MARKER();
;;;2238   				}
;;;2239   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2240   		}
;;;2241   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2242   
;;;2243   		/* Check for stack overflow, if configured. */
;;;2244   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2245   
;;;2246   		/* Select a new task to run using either the generic C or port
;;;2247   		optimised asm code. */
;;;2248   		taskSELECT_HIGHEST_PRIORITY_TASK();
000692  4874              LDR      r0,|L1.2148|
000694  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
000696  fab0f080          CLZ      r0,r0
00069a  f1c0011f          RSB      r1,r0,#0x1f
00069e  eb010281          ADD      r2,r1,r1,LSL #2
0006a2  4b71              LDR      r3,|L1.2152|
0006a4  eb030082          ADD      r0,r3,r2,LSL #2
0006a8  6842              LDR      r2,[r0,#4]
0006aa  6852              LDR      r2,[r2,#4]
0006ac  6042              STR      r2,[r0,#4]
0006ae  f1000208          ADD      r2,r0,#8
0006b2  6843              LDR      r3,[r0,#4]
0006b4  4293              CMP      r3,r2
0006b6  d102              BNE      |L1.1726|
0006b8  6842              LDR      r2,[r0,#4]
0006ba  6852              LDR      r2,[r2,#4]
0006bc  6042              STR      r2,[r0,#4]
                  |L1.1726|
0006be  6842              LDR      r2,[r0,#4]
0006c0  68d2              LDR      r2,[r2,#0xc]
0006c2  4b62              LDR      r3,|L1.2124|
0006c4  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
0006c6  bf00              NOP      
                  |L1.1736|
;;;2249   		traceTASK_SWITCHED_IN();
;;;2250   
;;;2251   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2252   		{
;;;2253   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2254   			structure specific to this task. */
;;;2255   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2256   		}
;;;2257   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2258   	}
;;;2259   }
0006c8  4770              BX       lr
;;;2260   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1283   
;;;1284   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
0006ca  b570              PUSH     {r4-r6,lr}
;;;1285   	{
0006cc  4605              MOV      r5,r0
;;;1286   	TCB_t *pxTCB;
;;;1287   
;;;1288   		taskENTER_CRITICAL();
0006ce  f7fffffe          BL       vPortEnterCritical
;;;1289   		{
;;;1290   			/* If null is passed in here then it is the running task that is
;;;1291   			being suspended. */
;;;1292   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
0006d2  b915              CBNZ     r5,|L1.1754|
0006d4  485d              LDR      r0,|L1.2124|
0006d6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0006d8  e000              B        |L1.1756|
                  |L1.1754|
0006da  4628              MOV      r0,r5
                  |L1.1756|
0006dc  4604              MOV      r4,r0
;;;1293   
;;;1294   			traceTASK_SUSPEND( pxTCB );
;;;1295   
;;;1296   			/* Remove task from the ready/delayed list and place in the
;;;1297   			suspended list. */
;;;1298   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0006de  1d20              ADDS     r0,r4,#4
0006e0  f7fffffe          BL       uxListRemove
0006e4  b970              CBNZ     r0,|L1.1796|
;;;1299   			{
;;;1300   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
0006e6  6ae0              LDR      r0,[r4,#0x2c]
0006e8  eb000080          ADD      r0,r0,r0,LSL #2
0006ec  495e              LDR      r1,|L1.2152|
0006ee  f8510020          LDR      r0,[r1,r0,LSL #2]
0006f2  b938              CBNZ     r0,|L1.1796|
0006f4  2001              MOVS     r0,#1
0006f6  6ae1              LDR      r1,[r4,#0x2c]
0006f8  4088              LSLS     r0,r0,r1
0006fa  495a              LDR      r1,|L1.2148|
0006fc  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0006fe  4381              BICS     r1,r1,r0
000700  4858              LDR      r0,|L1.2148|
000702  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1796|
;;;1301   			}
;;;1302   			else
;;;1303   			{
;;;1304   				mtCOVERAGE_TEST_MARKER();
;;;1305   			}
;;;1306   
;;;1307   			/* Is the task waiting on an event also? */
;;;1308   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000704  6aa0              LDR      r0,[r4,#0x28]
000706  b118              CBZ      r0,|L1.1808|
;;;1309   			{
;;;1310   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000708  f1040018          ADD      r0,r4,#0x18
00070c  f7fffffe          BL       uxListRemove
                  |L1.1808|
;;;1311   			}
;;;1312   			else
;;;1313   			{
;;;1314   				mtCOVERAGE_TEST_MARKER();
;;;1315   			}
;;;1316   
;;;1317   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000710  1d21              ADDS     r1,r4,#4
000712  4857              LDR      r0,|L1.2160|
000714  f7fffffe          BL       vListInsertEnd
;;;1318   		}
;;;1319   		taskEXIT_CRITICAL();
000718  f7fffffe          BL       vPortExitCritical
;;;1320   
;;;1321   		if( pxTCB == pxCurrentTCB )
00071c  484b              LDR      r0,|L1.2124|
00071e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000720  4284              CMP      r4,r0
000722  d112              BNE      |L1.1866|
;;;1322   		{
;;;1323   			if( xSchedulerRunning != pdFALSE )
000724  4853              LDR      r0,|L1.2164|
000726  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000728  b110              CBZ      r0,|L1.1840|
;;;1324   			{
;;;1325   				/* The current task has just been suspended. */
;;;1326   				configASSERT( uxSchedulerSuspended == 0 );
;;;1327   				portYIELD_WITHIN_API();
00072a  f7fffffe          BL       vPortYield
00072e  e015              B        |L1.1884|
                  |L1.1840|
;;;1328   			}
;;;1329   			else
;;;1330   			{
;;;1331   				/* The scheduler is not running, but the task that was pointed
;;;1332   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1333   				must be adjusted to point to a different task. */
;;;1334   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
000730  484f              LDR      r0,|L1.2160|
000732  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
000734  4950              LDR      r1,|L1.2168|
000736  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000738  4288              CMP      r0,r1
00073a  d103              BNE      |L1.1860|
;;;1335   				{
;;;1336   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1337   					NULL so when the next task is created pxCurrentTCB will
;;;1338   					be set to point to it no matter what its relative priority
;;;1339   					is. */
;;;1340   					pxCurrentTCB = NULL;
00073c  2000              MOVS     r0,#0
00073e  4943              LDR      r1,|L1.2124|
000740  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
000742  e00b              B        |L1.1884|
                  |L1.1860|
;;;1341   				}
;;;1342   				else
;;;1343   				{
;;;1344   					vTaskSwitchContext();
000744  f7fffffe          BL       vTaskSwitchContext
000748  e008              B        |L1.1884|
                  |L1.1866|
;;;1345   				}
;;;1346   			}
;;;1347   		}
;;;1348   		else
;;;1349   		{
;;;1350   			if( xSchedulerRunning != pdFALSE )
00074a  484a              LDR      r0,|L1.2164|
00074c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00074e  b128              CBZ      r0,|L1.1884|
;;;1351   			{
;;;1352   				/* A task other than the currently running task was suspended,
;;;1353   				reset the next expected unblock time in case it referred to the
;;;1354   				task that is now in the Suspended state. */
;;;1355   				taskENTER_CRITICAL();
000750  f7fffffe          BL       vPortEnterCritical
;;;1356   				{
;;;1357   					prvResetNextTaskUnblockTime();
000754  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1358   				}
;;;1359   				taskEXIT_CRITICAL();
000758  f7fffffe          BL       vPortExitCritical
                  |L1.1884|
;;;1360   			}
;;;1361   			else
;;;1362   			{
;;;1363   				mtCOVERAGE_TEST_MARKER();
;;;1364   			}
;;;1365   		}
;;;1366   	}
00075c  bd70              POP      {r4-r6,pc}
;;;1367   
                          ENDP

                  prvTaskIsTaskSuspended PROC
;;;1372   
;;;1373   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
00075e  b510              PUSH     {r4,lr}
;;;1374   	{
000760  4601              MOV      r1,r0
;;;1375   	BaseType_t xReturn = pdFALSE;
000762  2000              MOVS     r0,#0
;;;1376   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000764  460a              MOV      r2,r1
;;;1377   
;;;1378   		/* Accesses xPendingReadyList so must be called from a critical
;;;1379   		section. */
;;;1380   
;;;1381   		/* It does not make sense to check if the calling task is suspended. */
;;;1382   		configASSERT( xTask );
;;;1383   
;;;1384   		/* Is the task being resumed actually in the suspended list? */
;;;1385   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
000766  4c42              LDR      r4,|L1.2160|
000768  6953              LDR      r3,[r2,#0x14]
00076a  42a3              CMP      r3,r4
00076c  d101              BNE      |L1.1906|
00076e  2301              MOVS     r3,#1
000770  e000              B        |L1.1908|
                  |L1.1906|
000772  2300              MOVS     r3,#0
                  |L1.1908|
000774  b173              CBZ      r3,|L1.1940|
;;;1386   		{
;;;1387   			/* Has the task already been resumed from within an ISR? */
;;;1388   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000776  4c41              LDR      r4,|L1.2172|
000778  6a93              LDR      r3,[r2,#0x28]
00077a  42a3              CMP      r3,r4
00077c  d101              BNE      |L1.1922|
00077e  2301              MOVS     r3,#1
000780  e000              B        |L1.1924|
                  |L1.1922|
000782  2300              MOVS     r3,#0
                  |L1.1924|
000784  b933              CBNZ     r3,|L1.1940|
;;;1389   			{
;;;1390   				/* Is it in the suspended list because it is in the	Suspended
;;;1391   				state, or because is is blocked with no timeout? */
;;;1392   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000786  6a93              LDR      r3,[r2,#0x28]
000788  b90b              CBNZ     r3,|L1.1934|
00078a  2301              MOVS     r3,#1
00078c  e000              B        |L1.1936|
                  |L1.1934|
00078e  2300              MOVS     r3,#0
                  |L1.1936|
000790  b103              CBZ      r3,|L1.1940|
;;;1393   				{
;;;1394   					xReturn = pdTRUE;
000792  2001              MOVS     r0,#1
                  |L1.1940|
;;;1395   				}
;;;1396   				else
;;;1397   				{
;;;1398   					mtCOVERAGE_TEST_MARKER();
;;;1399   				}
;;;1400   			}
;;;1401   			else
;;;1402   			{
;;;1403   				mtCOVERAGE_TEST_MARKER();
;;;1404   			}
;;;1405   		}
;;;1406   		else
;;;1407   		{
;;;1408   			mtCOVERAGE_TEST_MARKER();
;;;1409   		}
;;;1410   
;;;1411   		return xReturn;
;;;1412   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000794  bd10              POP      {r4,pc}
;;;1413   
                          ENDP

                  vTaskResume PROC
;;;1418   
;;;1419   	void vTaskResume( TaskHandle_t xTaskToResume )
000796  b570              PUSH     {r4-r6,lr}
;;;1420   	{
000798  4605              MOV      r5,r0
;;;1421   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
00079a  462c              MOV      r4,r5
;;;1422   
;;;1423   		/* It does not make sense to resume the calling task. */
;;;1424   		configASSERT( xTaskToResume );
;;;1425   
;;;1426   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1427   		currently executing task. */
;;;1428   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
00079c  b344              CBZ      r4,|L1.2032|
00079e  482b              LDR      r0,|L1.2124|
0007a0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0007a2  4284              CMP      r4,r0
0007a4  d024              BEQ      |L1.2032|
;;;1429   		{
;;;1430   			taskENTER_CRITICAL();
0007a6  f7fffffe          BL       vPortEnterCritical
;;;1431   			{
;;;1432   				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0007aa  4620              MOV      r0,r4
0007ac  f7fffffe          BL       prvTaskIsTaskSuspended
0007b0  2801              CMP      r0,#1
0007b2  d11b              BNE      |L1.2028|
;;;1433   				{
;;;1434   					traceTASK_RESUME( pxTCB );
;;;1435   
;;;1436   					/* As we are in a critical section we can access the ready
;;;1437   					lists even if the scheduler is suspended. */
;;;1438   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
0007b4  1d20              ADDS     r0,r4,#4
0007b6  f7fffffe          BL       uxListRemove
;;;1439   					prvAddTaskToReadyList( pxTCB );
0007ba  2001              MOVS     r0,#1
0007bc  6ae1              LDR      r1,[r4,#0x2c]
0007be  4088              LSLS     r0,r0,r1
0007c0  4928              LDR      r1,|L1.2148|
0007c2  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0007c4  4308              ORRS     r0,r0,r1
0007c6  4927              LDR      r1,|L1.2148|
0007c8  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0007ca  6ae1              LDR      r1,[r4,#0x2c]
0007cc  eb010181          ADD      r1,r1,r1,LSL #2
0007d0  4a25              LDR      r2,|L1.2152|
0007d2  eb020081          ADD      r0,r2,r1,LSL #2
0007d6  1d21              ADDS     r1,r4,#4
0007d8  f7fffffe          BL       vListInsertEnd
;;;1440   
;;;1441   					/* We may have just resumed a higher priority task. */
;;;1442   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0007dc  491b              LDR      r1,|L1.2124|
0007de  6ae0              LDR      r0,[r4,#0x2c]
0007e0  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0007e2  6ac9              LDR      r1,[r1,#0x2c]
0007e4  4288              CMP      r0,r1
0007e6  d301              BCC      |L1.2028|
;;;1443   					{
;;;1444   						/* This yield may not cause the task just resumed to run,
;;;1445   						but will leave the lists in the correct state for the
;;;1446   						next yield. */
;;;1447   						taskYIELD_IF_USING_PREEMPTION();
0007e8  f7fffffe          BL       vPortYield
                  |L1.2028|
;;;1448   					}
;;;1449   					else
;;;1450   					{
;;;1451   						mtCOVERAGE_TEST_MARKER();
;;;1452   					}
;;;1453   				}
;;;1454   				else
;;;1455   				{
;;;1456   					mtCOVERAGE_TEST_MARKER();
;;;1457   				}
;;;1458   			}
;;;1459   			taskEXIT_CRITICAL();
0007ec  f7fffffe          BL       vPortExitCritical
                  |L1.2032|
;;;1460   		}
;;;1461   		else
;;;1462   		{
;;;1463   			mtCOVERAGE_TEST_MARKER();
;;;1464   		}
;;;1465   	}
0007f0  bd70              POP      {r4-r6,pc}
;;;1466   
                          ENDP

                  xTaskResumeFromISR PROC
;;;1472   
;;;1473   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
0007f2  e92d41f0          PUSH     {r4-r8,lr}
;;;1474   	{
0007f6  4605              MOV      r5,r0
;;;1475   	BaseType_t xYieldRequired = pdFALSE;
0007f8  2600              MOVS     r6,#0
;;;1476   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
0007fa  462c              MOV      r4,r5
;;;1477   	UBaseType_t uxSavedInterruptStatus;
;;;1478   
;;;1479   		configASSERT( xTaskToResume );
;;;1480   
;;;1481   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1482   		maximum	system call (or maximum API call) interrupt priority.
;;;1483   		Interrupts that are	above the maximum system call priority are keep
;;;1484   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1485   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1486   		is defined in FreeRTOSConfig.h then
;;;1487   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1488   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1489   		been assigned a priority above the configured maximum system call
;;;1490   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1491   		from interrupts	that have been assigned a priority at or (logically)
;;;1492   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1493   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1494   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1495   		provided on the following link:
;;;1496   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1497   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1498   
;;;1499   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0007fc  f7fffffe          BL       ulPortSetInterruptMask
000800  4607              MOV      r7,r0
;;;1500   		{
;;;1501   			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
000802  4620              MOV      r0,r4
000804  f7fffffe          BL       prvTaskIsTaskSuspended
000808  2801              CMP      r0,#1
00080a  d13e              BNE      |L1.2186|
;;;1502   			{
;;;1503   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1504   
;;;1505   				/* Check the ready lists can be accessed. */
;;;1506   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00080c  4814              LDR      r0,|L1.2144|
00080e  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000810  b9d8              CBNZ     r0,|L1.2122|
;;;1507   				{
;;;1508   					/* Ready lists can be accessed so move the task from the
;;;1509   					suspended list to the ready list directly. */
;;;1510   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000812  490e              LDR      r1,|L1.2124|
000814  6ae0              LDR      r0,[r4,#0x2c]
000816  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000818  6ac9              LDR      r1,[r1,#0x2c]
00081a  4288              CMP      r0,r1
00081c  d300              BCC      |L1.2080|
;;;1511   					{
;;;1512   						xYieldRequired = pdTRUE;
00081e  2601              MOVS     r6,#1
                  |L1.2080|
;;;1513   					}
;;;1514   					else
;;;1515   					{
;;;1516   						mtCOVERAGE_TEST_MARKER();
;;;1517   					}
;;;1518   
;;;1519   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
000820  1d20              ADDS     r0,r4,#4
000822  f7fffffe          BL       uxListRemove
;;;1520   					prvAddTaskToReadyList( pxTCB );
000826  2001              MOVS     r0,#1
000828  6ae1              LDR      r1,[r4,#0x2c]
00082a  4088              LSLS     r0,r0,r1
00082c  490d              LDR      r1,|L1.2148|
00082e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000830  4308              ORRS     r0,r0,r1
000832  490c              LDR      r1,|L1.2148|
000834  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000836  6ae1              LDR      r1,[r4,#0x2c]
000838  eb010181          ADD      r1,r1,r1,LSL #2
00083c  4a0a              LDR      r2,|L1.2152|
00083e  eb020081          ADD      r0,r2,r1,LSL #2
000842  1d21              ADDS     r1,r4,#4
000844  f7fffffe          BL       vListInsertEnd
000848  e01f              B        |L1.2186|
                  |L1.2122|
00084a  e019              B        |L1.2176|
                  |L1.2124|
                          DCD      pxCurrentTCB
                  |L1.2128|
                          DCD      xTickCount
                  |L1.2132|
                          DCD      pxOverflowDelayedTaskList
                  |L1.2136|
                          DCD      pxDelayedTaskList
                  |L1.2140|
                          DCD      xNextTaskUnblockTime
                  |L1.2144|
                          DCD      uxSchedulerSuspended
                  |L1.2148|
                          DCD      uxTopReadyPriority
                  |L1.2152|
                          DCD      pxReadyTasksLists
                  |L1.2156|
                          DCD      xYieldPending
                  |L1.2160|
                          DCD      xSuspendedTaskList
                  |L1.2164|
                          DCD      xSchedulerRunning
                  |L1.2168|
                          DCD      uxCurrentNumberOfTasks
                  |L1.2172|
                          DCD      xPendingReadyList
                  |L1.2176|
;;;1521   				}
;;;1522   				else
;;;1523   				{
;;;1524   					/* The delayed or ready lists cannot be accessed so the task
;;;1525   					is held in the pending ready list until the scheduler is
;;;1526   					unsuspended. */
;;;1527   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000880  f1040118          ADD      r1,r4,#0x18
000884  48ff              LDR      r0,|L1.3204|
000886  f7fffffe          BL       vListInsertEnd
                  |L1.2186|
;;;1528   				}
;;;1529   			}
;;;1530   			else
;;;1531   			{
;;;1532   				mtCOVERAGE_TEST_MARKER();
;;;1533   			}
;;;1534   		}
;;;1535   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00088a  4638              MOV      r0,r7
00088c  f7fffffe          BL       vPortClearInterruptMask
;;;1536   
;;;1537   		return xYieldRequired;
000890  4630              MOV      r0,r6
;;;1538   	}
000892  e8bd81f0          POP      {r4-r8,pc}
;;;1539   
                          ENDP

                  prvDeleteTCB PROC
;;;3310   
;;;3311   	static void prvDeleteTCB( TCB_t *pxTCB )
000896  b510              PUSH     {r4,lr}
;;;3312   	{
000898  4604              MOV      r4,r0
;;;3313   		/* This call is required specifically for the TriCore port.  It must be
;;;3314   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3315   		want to allocate and clean RAM statically. */
;;;3316   		portCLEAN_UP_TCB( pxTCB );
;;;3317   
;;;3318   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3319   		to the task to free any memory allocated at the application level. */
;;;3320   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3321   		{
;;;3322   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3323   		}
;;;3324   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3325   
;;;3326   		#if( portUSING_MPU_WRAPPERS == 1 )
;;;3327   		{
;;;3328   			/* Only free the stack if it was allocated dynamically in the first
;;;3329   			place. */
;;;3330   			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
;;;3331   			{
;;;3332   				vPortFreeAligned( pxTCB->pxStack );
;;;3333   			}
;;;3334   		}
;;;3335   		#else
;;;3336   		{
;;;3337   			vPortFreeAligned( pxTCB->pxStack );
00089a  6b20              LDR      r0,[r4,#0x30]
00089c  f7fffffe          BL       vPortFree
;;;3338   		}
;;;3339   		#endif
;;;3340   
;;;3341   		vPortFree( pxTCB );
0008a0  4620              MOV      r0,r4
0008a2  f7fffffe          BL       vPortFree
;;;3342   	}
0008a6  bd10              POP      {r4,pc}
;;;3343   
                          ENDP

                  prvCheckTasksWaitingTermination PROC
;;;3029   
;;;3030   static void prvCheckTasksWaitingTermination( void )
0008a8  b570              PUSH     {r4-r6,lr}
;;;3031   {
;;;3032   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3033   	{
;;;3034   		BaseType_t xListIsEmpty;
;;;3035   
;;;3036   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3037   		too often in the idle task. */
;;;3038   		while( uxTasksDeleted > ( UBaseType_t ) 0U )
0008aa  e023              B        |L1.2292|
                  |L1.2220|
;;;3039   		{
;;;3040   			vTaskSuspendAll();
0008ac  f7fffffe          BL       vTaskSuspendAll
;;;3041   			{
;;;3042   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
0008b0  48f5              LDR      r0,|L1.3208|
0008b2  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
0008b4  b908              CBNZ     r0,|L1.2234|
0008b6  2001              MOVS     r0,#1
0008b8  e000              B        |L1.2236|
                  |L1.2234|
0008ba  2000              MOVS     r0,#0
                  |L1.2236|
0008bc  4605              MOV      r5,r0
;;;3043   			}
;;;3044   			( void ) xTaskResumeAll();
0008be  f7fffffe          BL       xTaskResumeAll
;;;3045   
;;;3046   			if( xListIsEmpty == pdFALSE )
0008c2  b9bd              CBNZ     r5,|L1.2292|
;;;3047   			{
;;;3048   				TCB_t *pxTCB;
;;;3049   
;;;3050   				taskENTER_CRITICAL();
0008c4  f7fffffe          BL       vPortEnterCritical
;;;3051   				{
;;;3052   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
0008c8  48ef              LDR      r0,|L1.3208|
0008ca  68c0              LDR      r0,[r0,#0xc]
0008cc  68c4              LDR      r4,[r0,#0xc]
;;;3053   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
0008ce  1d20              ADDS     r0,r4,#4
0008d0  f7fffffe          BL       uxListRemove
;;;3054   					--uxCurrentNumberOfTasks;
0008d4  48ed              LDR      r0,|L1.3212|
0008d6  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
0008d8  1e40              SUBS     r0,r0,#1
0008da  49ec              LDR      r1,|L1.3212|
0008dc  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3055   					--uxTasksDeleted;
0008de  48ec              LDR      r0,|L1.3216|
0008e0  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
0008e2  1e40              SUBS     r0,r0,#1
0008e4  49ea              LDR      r1,|L1.3216|
0008e6  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;3056   				}
;;;3057   				taskEXIT_CRITICAL();
0008e8  f7fffffe          BL       vPortExitCritical
;;;3058   
;;;3059   				prvDeleteTCB( pxTCB );
0008ec  4620              MOV      r0,r4
0008ee  f7fffffe          BL       prvDeleteTCB
;;;3060   			}
0008f2  bf00              NOP      
                  |L1.2292|
0008f4  48e6              LDR      r0,|L1.3216|
0008f6  6800              LDR      r0,[r0,#0]            ;3038  ; uxTasksDeleted
0008f8  2800              CMP      r0,#0                 ;3038
0008fa  d1d7              BNE      |L1.2220|
;;;3061   			else
;;;3062   			{
;;;3063   				mtCOVERAGE_TEST_MARKER();
;;;3064   			}
;;;3065   		}
;;;3066   	}
;;;3067   	#endif /* vTaskDelete */
;;;3068   }
0008fc  bd70              POP      {r4-r6,pc}
;;;3069   /*-----------------------------------------------------------*/
                          ENDP

                  prvIdleTask PROC
;;;2689    */
;;;2690   static portTASK_FUNCTION( prvIdleTask, pvParameters )
0008fe  bf00              NOP      
                  |L1.2304|
;;;2691   {
;;;2692   	/* Stop warnings. */
;;;2693   	( void ) pvParameters;
;;;2694   
;;;2695   	for( ;; )
;;;2696   	{
;;;2697   		/* See if any tasks have been deleted. */
;;;2698   		prvCheckTasksWaitingTermination();
000900  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;2699   
;;;2700   		#if ( configUSE_PREEMPTION == 0 )
;;;2701   		{
;;;2702   			/* If we are not using preemption we keep forcing a task switch to
;;;2703   			see if any other task has become available.  If we are using
;;;2704   			preemption we don't need to do this as any task becoming available
;;;2705   			will automatically get the processor anyway. */
;;;2706   			taskYIELD();
;;;2707   		}
;;;2708   		#endif /* configUSE_PREEMPTION */
;;;2709   
;;;2710   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2711   		{
;;;2712   			/* When using preemption tasks of equal priority will be
;;;2713   			timesliced.  If a task that is sharing the idle priority is ready
;;;2714   			to run then the idle task should yield before the end of the
;;;2715   			timeslice.
;;;2716   
;;;2717   			A critical region is not required here as we are just reading from
;;;2718   			the list, and an occasional incorrect value will not matter.  If
;;;2719   			the ready list at the idle priority contains more than one task
;;;2720   			then a task other than the idle task is ready to execute. */
;;;2721   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000904  48e3              LDR      r0,|L1.3220|
000906  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
000908  2801              CMP      r0,#1
00090a  d9f9              BLS      |L1.2304|
;;;2722   			{
;;;2723   				taskYIELD();
00090c  f7fffffe          BL       vPortYield
000910  e7f6              B        |L1.2304|
;;;2724   			}
;;;2725   			else
;;;2726   			{
;;;2727   				mtCOVERAGE_TEST_MARKER();
;;;2728   			}
;;;2729   		}
;;;2730   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2731   
;;;2732   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2733   		{
;;;2734   			extern void vApplicationIdleHook( void );
;;;2735   
;;;2736   			/* Call the user defined function from within the idle task.  This
;;;2737   			allows the application designer to add background functionality
;;;2738   			without the overhead of a separate task.
;;;2739   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2740   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2741   			vApplicationIdleHook();
;;;2742   		}
;;;2743   		#endif /* configUSE_IDLE_HOOK */
;;;2744   
;;;2745   		/* This conditional compilation should use inequality to 0, not equality
;;;2746   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2747   		user defined low power mode	implementations require
;;;2748   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2749   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2750   		{
;;;2751   		TickType_t xExpectedIdleTime;
;;;2752   
;;;2753   			/* It is not desirable to suspend then resume the scheduler on
;;;2754   			each iteration of the idle task.  Therefore, a preliminary
;;;2755   			test of the expected idle time is performed without the
;;;2756   			scheduler suspended.  The result here is not necessarily
;;;2757   			valid. */
;;;2758   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2759   
;;;2760   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2761   			{
;;;2762   				vTaskSuspendAll();
;;;2763   				{
;;;2764   					/* Now the scheduler is suspended, the expected idle
;;;2765   					time can be sampled again, and this time its value can
;;;2766   					be used. */
;;;2767   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2768   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2769   
;;;2770   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2771   					{
;;;2772   						traceLOW_POWER_IDLE_BEGIN();
;;;2773   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2774   						traceLOW_POWER_IDLE_END();
;;;2775   					}
;;;2776   					else
;;;2777   					{
;;;2778   						mtCOVERAGE_TEST_MARKER();
;;;2779   					}
;;;2780   				}
;;;2781   				( void ) xTaskResumeAll();
;;;2782   			}
;;;2783   			else
;;;2784   			{
;;;2785   				mtCOVERAGE_TEST_MARKER();
;;;2786   			}
;;;2787   		}
;;;2788   		#endif /* configUSE_TICKLESS_IDLE */
;;;2789   	}
;;;2790   }
;;;2791   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1542   
;;;1543   void vTaskStartScheduler( void )
000912  b51f              PUSH     {r0-r4,lr}
;;;1544   {
;;;1545   BaseType_t xReturn;
;;;1546   
;;;1547   	/* Add the idle task at the lowest priority. */
;;;1548   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1549   	{
;;;1550   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1551   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1552   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1553   	}
;;;1554   	#else
;;;1555   	{
;;;1556   		/* Create the idle task without storing its handle. */
;;;1557   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000914  2300              MOVS     r3,#0
000916  9300              STR      r3,[sp,#0]
000918  9301              STR      r3,[sp,#4]
00091a  9302              STR      r3,[sp,#8]
00091c  2280              MOVS     r2,#0x80
00091e  a1de              ADR      r1,|L1.3224|
000920  48df              LDR      r0,|L1.3232|
000922  9303              STR      r3,[sp,#0xc]
000924  f7fffffe          BL       xTaskGenericCreate
000928  4604              MOV      r4,r0
;;;1558   	}
;;;1559   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1560   
;;;1561   	#if ( configUSE_TIMERS == 1 )
;;;1562   	{
;;;1563   		if( xReturn == pdPASS )
00092a  2c01              CMP      r4,#1
00092c  d102              BNE      |L1.2356|
;;;1564   		{
;;;1565   			xReturn = xTimerCreateTimerTask();
00092e  f7fffffe          BL       xTimerCreateTimerTask
000932  4604              MOV      r4,r0
                  |L1.2356|
;;;1566   		}
;;;1567   		else
;;;1568   		{
;;;1569   			mtCOVERAGE_TEST_MARKER();
;;;1570   		}
;;;1571   	}
;;;1572   	#endif /* configUSE_TIMERS */
;;;1573   
;;;1574   	if( xReturn == pdPASS )
000934  2c01              CMP      r4,#1
000936  d10c              BNE      |L1.2386|
;;;1575   	{
;;;1576   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1577   		before or during the call to xPortStartScheduler().  The stacks of
;;;1578   		the created tasks contain a status word with interrupts switched on
;;;1579   		so interrupts will automatically get re-enabled when the first task
;;;1580   		starts to run. */
;;;1581   		portDISABLE_INTERRUPTS();
000938  f7fffffe          BL       ulPortSetInterruptMask
;;;1582   
;;;1583   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1584   		{
;;;1585   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1586   			structure specific to the task that will run first. */
;;;1587   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1588   		}
;;;1589   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1590   
;;;1591   		xNextTaskUnblockTime = portMAX_DELAY;
00093c  1ea0              SUBS     r0,r4,#2
00093e  49d9              LDR      r1,|L1.3236|
000940  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1592   		xSchedulerRunning = pdTRUE;
000942  2001              MOVS     r0,#1
000944  49d8              LDR      r1,|L1.3240|
000946  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1593   		xTickCount = ( TickType_t ) 0U;
000948  2000              MOVS     r0,#0
00094a  49d8              LDR      r1,|L1.3244|
00094c  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1594   
;;;1595   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1596   		macro must be defined to configure the timer/counter used to generate
;;;1597   		the run time counter time base. */
;;;1598   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1599   
;;;1600   		/* Setting up the timer tick is hardware specific and thus in the
;;;1601   		portable interface. */
;;;1602   		if( xPortStartScheduler() != pdFALSE )
00094e  f7fffffe          BL       xPortStartScheduler
                  |L1.2386|
;;;1603   		{
;;;1604   			/* Should not reach here as if the scheduler is running the
;;;1605   			function will not return. */
;;;1606   		}
;;;1607   		else
;;;1608   		{
;;;1609   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1610   		}
;;;1611   	}
;;;1612   	else
;;;1613   	{
;;;1614   		/* This line will only be reached if the kernel could not be started,
;;;1615   		because there was not enough FreeRTOS heap to create the idle task
;;;1616   		or the timer task. */
;;;1617   		configASSERT( xReturn );
;;;1618   	}
;;;1619   }
000952  bd1f              POP      {r0-r4,pc}
;;;1620   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1621   
;;;1622   void vTaskEndScheduler( void )
000954  b510              PUSH     {r4,lr}
;;;1623   {
;;;1624   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1625   	routine so the original ISRs can be restored if necessary.  The port
;;;1626   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1627   	portDISABLE_INTERRUPTS();
000956  f7fffffe          BL       ulPortSetInterruptMask
;;;1628   	xSchedulerRunning = pdFALSE;
00095a  2000              MOVS     r0,#0
00095c  49d2              LDR      r1,|L1.3240|
00095e  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1629   	vPortEndScheduler();
000960  f7fffffe          BL       vPortEndScheduler
;;;1630   }
000964  bd10              POP      {r4,pc}
;;;1631   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;1763   
;;;1764   TickType_t xTaskGetTickCount( void )
000966  49d1              LDR      r1,|L1.3244|
;;;1765   {
;;;1766   TickType_t xTicks;
;;;1767   
;;;1768   	/* Critical section required if running on a 16 bit processor. */
;;;1769   	portTICK_TYPE_ENTER_CRITICAL();
;;;1770   	{
;;;1771   		xTicks = xTickCount;
000968  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;1772   	}
;;;1773   	portTICK_TYPE_EXIT_CRITICAL();
;;;1774   
;;;1775   	return xTicks;
;;;1776   }
00096a  4770              BX       lr
;;;1777   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;1778   
;;;1779   TickType_t xTaskGetTickCountFromISR( void )
00096c  2100              MOVS     r1,#0
;;;1780   {
;;;1781   TickType_t xReturn;
;;;1782   UBaseType_t uxSavedInterruptStatus;
;;;1783   
;;;1784   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1785   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1786   	above the maximum system call priority are kept permanently enabled, even
;;;1787   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1788   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1789   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1790   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1791   	assigned a priority above the configured maximum system call priority.
;;;1792   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1793   	that have been assigned a priority at or (logically) below the maximum
;;;1794   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1795   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1796   	More information (albeit Cortex-M specific) is provided on the following
;;;1797   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1798   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1799   
;;;1800   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;1801   	{
;;;1802   		xReturn = xTickCount;
00096e  4acf              LDR      r2,|L1.3244|
000970  6810              LDR      r0,[r2,#0]  ; xTickCount
;;;1803   	}
;;;1804   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1805   
;;;1806   	return xReturn;
;;;1807   }
000972  4770              BX       lr
;;;1808   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;1809   
;;;1810   UBaseType_t uxTaskGetNumberOfTasks( void )
000974  48c5              LDR      r0,|L1.3212|
;;;1811   {
;;;1812   	/* A critical section is not required because the variables are of type
;;;1813   	BaseType_t. */
;;;1814   	return uxCurrentNumberOfTasks;
000976  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;1815   }
000978  4770              BX       lr
;;;1816   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;2261   
;;;2262   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
00097a  b570              PUSH     {r4-r6,lr}
;;;2263   {
00097c  4606              MOV      r6,r0
00097e  460c              MOV      r4,r1
;;;2264   TickType_t xTimeToWake;
;;;2265   
;;;2266   	configASSERT( pxEventList );
;;;2267   
;;;2268   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2269   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2270   
;;;2271   	/* Place the event list item of the TCB in the appropriate event list.
;;;2272   	This is placed in the list in priority order so the highest priority task
;;;2273   	is the first to be woken by the event.  The queue that contains the event
;;;2274   	list is locked, preventing simultaneous access from interrupts. */
;;;2275   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000980  48cb              LDR      r0,|L1.3248|
000982  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000984  3118              ADDS     r1,r1,#0x18
000986  4630              MOV      r0,r6
000988  f7fffffe          BL       vListInsert
;;;2276   
;;;2277   	/* The task must be removed from from the ready list before it is added to
;;;2278   	the blocked list as the same list item is used for both lists.  Exclusive
;;;2279   	access to the ready lists guaranteed because the scheduler is locked. */
;;;2280   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00098c  48c8              LDR      r0,|L1.3248|
00098e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000990  1d00              ADDS     r0,r0,#4
000992  f7fffffe          BL       uxListRemove
000996  b948              CBNZ     r0,|L1.2476|
;;;2281   	{
;;;2282   		/* The current task must be in a ready list, so there is no need to
;;;2283   		check, and the port reset macro can be called directly. */
;;;2284   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000998  48c5              LDR      r0,|L1.3248|
00099a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00099c  6ac1              LDR      r1,[r0,#0x2c]
00099e  2001              MOVS     r0,#1
0009a0  4088              LSLS     r0,r0,r1
0009a2  49c4              LDR      r1,|L1.3252|
0009a4  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0009a6  4381              BICS     r1,r1,r0
0009a8  48c2              LDR      r0,|L1.3252|
0009aa  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.2476|
;;;2285   	}
;;;2286   	else
;;;2287   	{
;;;2288   		mtCOVERAGE_TEST_MARKER();
;;;2289   	}
;;;2290   
;;;2291   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2292   	{
;;;2293   		if( xTicksToWait == portMAX_DELAY )
0009ac  1c60              ADDS     r0,r4,#1
0009ae  d106              BNE      |L1.2494|
;;;2294   		{
;;;2295   			/* Add the task to the suspended task list instead of a delayed task
;;;2296   			list to ensure the task is not woken by a timing event.  It will
;;;2297   			block indefinitely. */
;;;2298   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
0009b0  48bf              LDR      r0,|L1.3248|
0009b2  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0009b4  1d09              ADDS     r1,r1,#4
0009b6  48c0              LDR      r0,|L1.3256|
0009b8  f7fffffe          BL       vListInsertEnd
0009bc  e005              B        |L1.2506|
                  |L1.2494|
;;;2299   		}
;;;2300   		else
;;;2301   		{
;;;2302   			/* Calculate the time at which the task should be woken if the event
;;;2303   			does not occur.  This may overflow but this doesn't matter, the
;;;2304   			scheduler will handle it. */
;;;2305   			xTimeToWake = xTickCount + xTicksToWait;
0009be  48bb              LDR      r0,|L1.3244|
0009c0  6800              LDR      r0,[r0,#0]  ; xTickCount
0009c2  1905              ADDS     r5,r0,r4
;;;2306   			prvAddCurrentTaskToDelayedList( xTimeToWake );
0009c4  4628              MOV      r0,r5
0009c6  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.2506|
;;;2307   		}
;;;2308   	}
;;;2309   	#else /* INCLUDE_vTaskSuspend */
;;;2310   	{
;;;2311   			/* Calculate the time at which the task should be woken if the event does
;;;2312   			not occur.  This may overflow but this doesn't matter, the scheduler
;;;2313   			will handle it. */
;;;2314   			xTimeToWake = xTickCount + xTicksToWait;
;;;2315   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2316   	}
;;;2317   	#endif /* INCLUDE_vTaskSuspend */
;;;2318   }
0009ca  bd70              POP      {r4-r6,pc}
;;;2319   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnUnorderedEventList PROC
;;;2320   
;;;2321   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
0009cc  e92d41f0          PUSH     {r4-r8,lr}
;;;2322   {
0009d0  4607              MOV      r7,r0
0009d2  460d              MOV      r5,r1
0009d4  4614              MOV      r4,r2
;;;2323   TickType_t xTimeToWake;
;;;2324   
;;;2325   	configASSERT( pxEventList );
;;;2326   
;;;2327   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2328   	the event groups implementation. */
;;;2329   	configASSERT( uxSchedulerSuspended != 0 );
;;;2330   
;;;2331   	/* Store the item value in the event list item.  It is safe to access the
;;;2332   	event list item here as interrupts won't access the event list item of a
;;;2333   	task that is not in the Blocked state. */
;;;2334   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0009d6  f0454000          ORR      r0,r5,#0x80000000
0009da  49b5              LDR      r1,|L1.3248|
0009dc  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0009de  6188              STR      r0,[r1,#0x18]
;;;2335   
;;;2336   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2337   	list.  It is safe to access the event list here because it is part of an
;;;2338   	event group implementation - and interrupts don't access event groups
;;;2339   	directly (instead they access them indirectly by pending function calls to
;;;2340   	the task level). */
;;;2341   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0009e0  48b3              LDR      r0,|L1.3248|
0009e2  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0009e4  3118              ADDS     r1,r1,#0x18
0009e6  4638              MOV      r0,r7
0009e8  f7fffffe          BL       vListInsertEnd
;;;2342   
;;;2343   	/* The task must be removed from the ready list before it is added to the
;;;2344   	blocked list.  Exclusive access can be assured to the ready list as the
;;;2345   	scheduler is locked. */
;;;2346   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0009ec  48b0              LDR      r0,|L1.3248|
0009ee  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0009f0  1d00              ADDS     r0,r0,#4
0009f2  f7fffffe          BL       uxListRemove
0009f6  b948              CBNZ     r0,|L1.2572|
;;;2347   	{
;;;2348   		/* The current task must be in a ready list, so there is no need to
;;;2349   		check, and the port reset macro can be called directly. */
;;;2350   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0009f8  48ad              LDR      r0,|L1.3248|
0009fa  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0009fc  6ac1              LDR      r1,[r0,#0x2c]
0009fe  2001              MOVS     r0,#1
000a00  4088              LSLS     r0,r0,r1
000a02  49ac              LDR      r1,|L1.3252|
000a04  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000a06  4381              BICS     r1,r1,r0
000a08  48aa              LDR      r0,|L1.3252|
000a0a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.2572|
;;;2351   	}
;;;2352   	else
;;;2353   	{
;;;2354   		mtCOVERAGE_TEST_MARKER();
;;;2355   	}
;;;2356   
;;;2357   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2358   	{
;;;2359   		if( xTicksToWait == portMAX_DELAY )
000a0c  1c60              ADDS     r0,r4,#1
000a0e  d106              BNE      |L1.2590|
;;;2360   		{
;;;2361   			/* Add the task to the suspended task list instead of a delayed task
;;;2362   			list to ensure it is not woken by a timing event.  It will block
;;;2363   			indefinitely. */
;;;2364   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000a10  48a7              LDR      r0,|L1.3248|
000a12  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000a14  1d09              ADDS     r1,r1,#4
000a16  48a8              LDR      r0,|L1.3256|
000a18  f7fffffe          BL       vListInsertEnd
000a1c  e005              B        |L1.2602|
                  |L1.2590|
;;;2365   		}
;;;2366   		else
;;;2367   		{
;;;2368   			/* Calculate the time at which the task should be woken if the event
;;;2369   			does not occur.  This may overflow but this doesn't matter, the
;;;2370   			kernel will manage it correctly. */
;;;2371   			xTimeToWake = xTickCount + xTicksToWait;
000a1e  48a3              LDR      r0,|L1.3244|
000a20  6800              LDR      r0,[r0,#0]  ; xTickCount
000a22  1906              ADDS     r6,r0,r4
;;;2372   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000a24  4630              MOV      r0,r6
000a26  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.2602|
;;;2373   		}
;;;2374   	}
;;;2375   	#else /* INCLUDE_vTaskSuspend */
;;;2376   	{
;;;2377   			/* Calculate the time at which the task should be woken if the event does
;;;2378   			not occur.  This may overflow but this doesn't matter, the kernel
;;;2379   			will manage it correctly. */
;;;2380   			xTimeToWake = xTickCount + xTicksToWait;
;;;2381   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2382   	}
;;;2383   	#endif /* INCLUDE_vTaskSuspend */
;;;2384   }
000a2a  e8bd81f0          POP      {r4-r8,pc}
;;;2385   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventListRestricted PROC
;;;2388   
;;;2389   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000a2e  e92d41f0          PUSH     {r4-r8,lr}
;;;2390   	{
000a32  4607              MOV      r7,r0
000a34  460c              MOV      r4,r1
000a36  4615              MOV      r5,r2
;;;2391   	TickType_t xTimeToWake;
;;;2392   
;;;2393   		configASSERT( pxEventList );
;;;2394   
;;;2395   		/* This function should not be called by application code hence the
;;;2396   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2397   		designed for use by kernel code, and has special calling requirements -
;;;2398   		it should be called with the scheduler suspended. */
;;;2399   
;;;2400   
;;;2401   		/* Place the event list item of the TCB in the appropriate event list.
;;;2402   		In this case it is assume that this is the only task that is going to
;;;2403   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2404   		can be used in place of vListInsert. */
;;;2405   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000a38  489d              LDR      r0,|L1.3248|
000a3a  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000a3c  3118              ADDS     r1,r1,#0x18
000a3e  4638              MOV      r0,r7
000a40  f7fffffe          BL       vListInsertEnd
;;;2406   
;;;2407   		/* We must remove this task from the ready list before adding it to the
;;;2408   		blocked list as the same list item is used for both lists.  This
;;;2409   		function is called with the scheduler locked so interrupts will not
;;;2410   		access the lists at the same time. */
;;;2411   		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000a44  489a              LDR      r0,|L1.3248|
000a46  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000a48  1d00              ADDS     r0,r0,#4
000a4a  f7fffffe          BL       uxListRemove
000a4e  b948              CBNZ     r0,|L1.2660|
;;;2412   		{
;;;2413   			/* The current task must be in a ready list, so there is no need to
;;;2414   			check, and the port reset macro can be called directly. */
;;;2415   			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000a50  4897              LDR      r0,|L1.3248|
000a52  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000a54  6ac1              LDR      r1,[r0,#0x2c]
000a56  2001              MOVS     r0,#1
000a58  4088              LSLS     r0,r0,r1
000a5a  4996              LDR      r1,|L1.3252|
000a5c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000a5e  4381              BICS     r1,r1,r0
000a60  4894              LDR      r0,|L1.3252|
000a62  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.2660|
;;;2416   		}
;;;2417   		else
;;;2418   		{
;;;2419   			mtCOVERAGE_TEST_MARKER();
;;;2420   		}
;;;2421   
;;;2422   		/* If vTaskSuspend() is available then the suspended task list is also
;;;2423   		available and a task that is blocking indefinitely can enter the
;;;2424   		suspended state (it is not really suspended as it will re-enter the
;;;2425   		Ready state when the event it is waiting indefinitely for occurs).
;;;2426   		Blocking indefinitely is useful when using tickless idle mode as when
;;;2427   		all tasks are blocked indefinitely all timers can be turned off. */
;;;2428   		#if( INCLUDE_vTaskSuspend == 1 )
;;;2429   		{
;;;2430   			if( xWaitIndefinitely == pdTRUE )
000a64  2d01              CMP      r5,#1
000a66  d106              BNE      |L1.2678|
;;;2431   			{
;;;2432   				/* Add the task to the suspended task list instead of a delayed
;;;2433   				task list to ensure the task is not woken by a timing event.  It
;;;2434   				will block indefinitely. */
;;;2435   				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000a68  4891              LDR      r0,|L1.3248|
000a6a  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000a6c  1d09              ADDS     r1,r1,#4
000a6e  4892              LDR      r0,|L1.3256|
000a70  f7fffffe          BL       vListInsertEnd
000a74  e005              B        |L1.2690|
                  |L1.2678|
;;;2436   			}
;;;2437   			else
;;;2438   			{
;;;2439   				/* Calculate the time at which the task should be woken if the
;;;2440   				event does not occur.  This may overflow but this doesn't
;;;2441   				matter. */
;;;2442   				xTimeToWake = xTickCount + xTicksToWait;
000a76  488d              LDR      r0,|L1.3244|
000a78  6800              LDR      r0,[r0,#0]  ; xTickCount
000a7a  1906              ADDS     r6,r0,r4
;;;2443   				traceTASK_DELAY_UNTIL();
;;;2444   				prvAddCurrentTaskToDelayedList( xTimeToWake );
000a7c  4630              MOV      r0,r6
000a7e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.2690|
;;;2445   			}
;;;2446   		}
;;;2447   		#else
;;;2448   		{
;;;2449   			/* Calculate the time at which the task should be woken if the event
;;;2450   			does not occur.  This may overflow but this doesn't matter. */
;;;2451   			xTimeToWake = xTickCount + xTicksToWait;
;;;2452   			traceTASK_DELAY_UNTIL();
;;;2453   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2454   
;;;2455   			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
;;;2456   			defined. */
;;;2457   			( void ) xWaitIndefinitely;
;;;2458   		}
;;;2459   		#endif
;;;2460   	}
000a82  e8bd81f0          POP      {r4-r8,pc}
;;;2461   
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;2464   
;;;2465   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000a86  b570              PUSH     {r4-r6,lr}
;;;2466   {
000a88  4606              MOV      r6,r0
;;;2467   TCB_t *pxUnblockedTCB;
;;;2468   BaseType_t xReturn;
;;;2469   
;;;2470   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2471   	called from a critical section within an ISR. */
;;;2472   
;;;2473   	/* The event list is sorted in priority order, so the first in the list can
;;;2474   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2475   	the delayed list, and add it to the ready list.
;;;2476   
;;;2477   	If an event is for a queue that is locked then this function will never
;;;2478   	get called - the lock count on the queue will get modified instead.  This
;;;2479   	means exclusive access to the event list is guaranteed here.
;;;2480   
;;;2481   	This function assumes that a check has already been made to ensure that
;;;2482   	pxEventList is not empty. */
;;;2483   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000a8a  68f0              LDR      r0,[r6,#0xc]
000a8c  68c4              LDR      r4,[r0,#0xc]
;;;2484   	configASSERT( pxUnblockedTCB );
;;;2485   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000a8e  f1040018          ADD      r0,r4,#0x18
000a92  f7fffffe          BL       uxListRemove
;;;2486   
;;;2487   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000a96  4889              LDR      r0,|L1.3260|
000a98  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000a9a  b9a0              CBNZ     r0,|L1.2758|
;;;2488   	{
;;;2489   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000a9c  1d20              ADDS     r0,r4,#4
000a9e  f7fffffe          BL       uxListRemove
;;;2490   		prvAddTaskToReadyList( pxUnblockedTCB );
000aa2  2001              MOVS     r0,#1
000aa4  6ae1              LDR      r1,[r4,#0x2c]
000aa6  4088              LSLS     r0,r0,r1
000aa8  4982              LDR      r1,|L1.3252|
000aaa  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000aac  4308              ORRS     r0,r0,r1
000aae  4981              LDR      r1,|L1.3252|
000ab0  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000ab2  6ae1              LDR      r1,[r4,#0x2c]
000ab4  eb010181          ADD      r1,r1,r1,LSL #2
000ab8  4a76              LDR      r2,|L1.3220|
000aba  eb020081          ADD      r0,r2,r1,LSL #2
000abe  1d21              ADDS     r1,r4,#4
000ac0  f7fffffe          BL       vListInsertEnd
000ac4  e004              B        |L1.2768|
                  |L1.2758|
;;;2491   	}
;;;2492   	else
;;;2493   	{
;;;2494   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2495   		pending until the scheduler is resumed. */
;;;2496   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000ac6  f1040118          ADD      r1,r4,#0x18
000aca  486e              LDR      r0,|L1.3204|
000acc  f7fffffe          BL       vListInsertEnd
                  |L1.2768|
;;;2497   	}
;;;2498   
;;;2499   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000ad0  4977              LDR      r1,|L1.3248|
000ad2  6ae0              LDR      r0,[r4,#0x2c]
000ad4  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000ad6  6ac9              LDR      r1,[r1,#0x2c]
000ad8  4288              CMP      r0,r1
000ada  d904              BLS      |L1.2790|
;;;2500   	{
;;;2501   		/* Return true if the task removed from the event list has a higher
;;;2502   		priority than the calling task.  This allows the calling task to know if
;;;2503   		it should force a context switch now. */
;;;2504   		xReturn = pdTRUE;
000adc  2501              MOVS     r5,#1
;;;2505   
;;;2506   		/* Mark that a yield is pending in case the user is not using the
;;;2507   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2508   		xYieldPending = pdTRUE;
000ade  2001              MOVS     r0,#1
000ae0  4977              LDR      r1,|L1.3264|
000ae2  6008              STR      r0,[r1,#0]  ; xYieldPending
000ae4  e000              B        |L1.2792|
                  |L1.2790|
;;;2509   	}
;;;2510   	else
;;;2511   	{
;;;2512   		xReturn = pdFALSE;
000ae6  2500              MOVS     r5,#0
                  |L1.2792|
;;;2513   	}
;;;2514   
;;;2515   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2516   	{
;;;2517   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2518   		might be set to the blocked task's time out time.  If the task is
;;;2519   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2520   		normally left unchanged, because it is automatically reset to a new
;;;2521   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2522   		tickless idling is used it might be more important to enter sleep mode
;;;2523   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2524   		ensure it is updated at the earliest possible time. */
;;;2525   		prvResetNextTaskUnblockTime();
;;;2526   	}
;;;2527   	#endif
;;;2528   
;;;2529   	return xReturn;
000ae8  4628              MOV      r0,r5
;;;2530   }
000aea  bd70              POP      {r4-r6,pc}
;;;2531   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromUnorderedEventList PROC
;;;2532   
;;;2533   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000aec  e92d41f0          PUSH     {r4-r8,lr}
;;;2534   {
000af0  4605              MOV      r5,r0
000af2  460f              MOV      r7,r1
;;;2535   TCB_t *pxUnblockedTCB;
;;;2536   BaseType_t xReturn;
;;;2537   
;;;2538   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2539   	the event flags implementation. */
;;;2540   	configASSERT( uxSchedulerSuspended != pdFALSE );
;;;2541   
;;;2542   	/* Store the new item value in the event list. */
;;;2543   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000af4  f0474000          ORR      r0,r7,#0x80000000
000af8  6028              STR      r0,[r5,#0]
;;;2544   
;;;2545   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2546   	event flags. */
;;;2547   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
000afa  68ec              LDR      r4,[r5,#0xc]
;;;2548   	configASSERT( pxUnblockedTCB );
;;;2549   	( void ) uxListRemove( pxEventListItem );
000afc  4628              MOV      r0,r5
000afe  f7fffffe          BL       uxListRemove
;;;2550   
;;;2551   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2552   	scheduler is suspended so interrupts will not be accessing the ready
;;;2553   	lists. */
;;;2554   	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000b02  1d20              ADDS     r0,r4,#4
000b04  f7fffffe          BL       uxListRemove
;;;2555   	prvAddTaskToReadyList( pxUnblockedTCB );
000b08  2001              MOVS     r0,#1
000b0a  6ae1              LDR      r1,[r4,#0x2c]
000b0c  4088              LSLS     r0,r0,r1
000b0e  4969              LDR      r1,|L1.3252|
000b10  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000b12  4308              ORRS     r0,r0,r1
000b14  4967              LDR      r1,|L1.3252|
000b16  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000b18  6ae1              LDR      r1,[r4,#0x2c]
000b1a  eb010181          ADD      r1,r1,r1,LSL #2
000b1e  4a5d              LDR      r2,|L1.3220|
000b20  eb020081          ADD      r0,r2,r1,LSL #2
000b24  1d21              ADDS     r1,r4,#4
000b26  f7fffffe          BL       vListInsertEnd
;;;2556   
;;;2557   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000b2a  4961              LDR      r1,|L1.3248|
000b2c  6ae0              LDR      r0,[r4,#0x2c]
000b2e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000b30  6ac9              LDR      r1,[r1,#0x2c]
000b32  4288              CMP      r0,r1
000b34  d904              BLS      |L1.2880|
;;;2558   	{
;;;2559   		/* Return true if the task removed from the event list has
;;;2560   		a higher priority than the calling task.  This allows
;;;2561   		the calling task to know if it should force a context
;;;2562   		switch now. */
;;;2563   		xReturn = pdTRUE;
000b36  2601              MOVS     r6,#1
;;;2564   
;;;2565   		/* Mark that a yield is pending in case the user is not using the
;;;2566   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2567   		xYieldPending = pdTRUE;
000b38  2001              MOVS     r0,#1
000b3a  4961              LDR      r1,|L1.3264|
000b3c  6008              STR      r0,[r1,#0]  ; xYieldPending
000b3e  e000              B        |L1.2882|
                  |L1.2880|
;;;2568   	}
;;;2569   	else
;;;2570   	{
;;;2571   		xReturn = pdFALSE;
000b40  2600              MOVS     r6,#0
                  |L1.2882|
;;;2572   	}
;;;2573   
;;;2574   	return xReturn;
000b42  4630              MOV      r0,r6
;;;2575   }
000b44  e8bd81f0          POP      {r4-r8,pc}
;;;2576   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;2577   
;;;2578   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000b48  495e              LDR      r1,|L1.3268|
;;;2579   {
;;;2580   	configASSERT( pxTimeOut );
;;;2581   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000b4a  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000b4c  6001              STR      r1,[r0,#0]
;;;2582   	pxTimeOut->xTimeOnEntering = xTickCount;
000b4e  4957              LDR      r1,|L1.3244|
000b50  6809              LDR      r1,[r1,#0]  ; xTickCount
000b52  6041              STR      r1,[r0,#4]
;;;2583   }
000b54  4770              BX       lr
;;;2584   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;2585   
;;;2586   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000b56  b570              PUSH     {r4-r6,lr}
;;;2587   {
000b58  4604              MOV      r4,r0
000b5a  460d              MOV      r5,r1
;;;2588   BaseType_t xReturn;
;;;2589   
;;;2590   	configASSERT( pxTimeOut );
;;;2591   	configASSERT( pxTicksToWait );
;;;2592   
;;;2593   	taskENTER_CRITICAL();
000b5c  f7fffffe          BL       vPortEnterCritical
;;;2594   	{
;;;2595   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2596   		const TickType_t xConstTickCount = xTickCount;
000b60  4852              LDR      r0,|L1.3244|
000b62  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;2597   
;;;2598   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2599   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2600   			the maximum block time then the task should block indefinitely, and
;;;2601   			therefore never time out. */
;;;2602   			if( *pxTicksToWait == portMAX_DELAY )
000b64  6828              LDR      r0,[r5,#0]
000b66  1c40              ADDS     r0,r0,#1
000b68  d101              BNE      |L1.2926|
;;;2603   			{
;;;2604   				xReturn = pdFALSE;
000b6a  2600              MOVS     r6,#0
000b6c  e019              B        |L1.2978|
                  |L1.2926|
;;;2605   			}
;;;2606   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2607   		#endif
;;;2608   
;;;2609   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000b6e  4955              LDR      r1,|L1.3268|
000b70  6820              LDR      r0,[r4,#0]
000b72  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000b74  4288              CMP      r0,r1
000b76  d004              BEQ      |L1.2946|
000b78  6860              LDR      r0,[r4,#4]
000b7a  4290              CMP      r0,r2
000b7c  d801              BHI      |L1.2946|
;;;2610   		{
;;;2611   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2612   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2613   			It must have wrapped all the way around and gone past us again. This
;;;2614   			passed since vTaskSetTimeout() was called. */
;;;2615   			xReturn = pdTRUE;
000b7e  2601              MOVS     r6,#1
000b80  e00f              B        |L1.2978|
                  |L1.2946|
;;;2616   		}
;;;2617   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
000b82  6860              LDR      r0,[r4,#4]
000b84  1a10              SUBS     r0,r2,r0
000b86  6829              LDR      r1,[r5,#0]
000b88  4288              CMP      r0,r1
000b8a  d209              BCS      |L1.2976|
;;;2618   		{
;;;2619   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2620   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
000b8c  6828              LDR      r0,[r5,#0]
000b8e  6861              LDR      r1,[r4,#4]
000b90  1a51              SUBS     r1,r2,r1
000b92  1a40              SUBS     r0,r0,r1
000b94  6028              STR      r0,[r5,#0]
;;;2621   			vTaskSetTimeOutState( pxTimeOut );
000b96  4620              MOV      r0,r4
000b98  f7fffffe          BL       vTaskSetTimeOutState
;;;2622   			xReturn = pdFALSE;
000b9c  2600              MOVS     r6,#0
000b9e  e000              B        |L1.2978|
                  |L1.2976|
;;;2623   		}
;;;2624   		else
;;;2625   		{
;;;2626   			xReturn = pdTRUE;
000ba0  2601              MOVS     r6,#1
                  |L1.2978|
;;;2627   		}
;;;2628   	}
;;;2629   	taskEXIT_CRITICAL();
000ba2  f7fffffe          BL       vPortExitCritical
;;;2630   
;;;2631   	return xReturn;
000ba6  4630              MOV      r0,r6
;;;2632   }
000ba8  bd70              POP      {r4-r6,pc}
;;;2633   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;2634   
;;;2635   void vTaskMissedYield( void )
000baa  2001              MOVS     r0,#1
;;;2636   {
;;;2637   	xYieldPending = pdTRUE;
000bac  4944              LDR      r1,|L1.3264|
000bae  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2638   }
000bb0  4770              BX       lr
;;;2639   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetSchedulerState PROC
;;;3389   
;;;3390   	BaseType_t xTaskGetSchedulerState( void )
000bb2  493d              LDR      r1,|L1.3240|
;;;3391   	{
;;;3392   	BaseType_t xReturn;
;;;3393   
;;;3394   		if( xSchedulerRunning == pdFALSE )
000bb4  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000bb6  b909              CBNZ     r1,|L1.3004|
;;;3395   		{
;;;3396   			xReturn = taskSCHEDULER_NOT_STARTED;
000bb8  2001              MOVS     r0,#1
000bba  e005              B        |L1.3016|
                  |L1.3004|
;;;3397   		}
;;;3398   		else
;;;3399   		{
;;;3400   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000bbc  493f              LDR      r1,|L1.3260|
000bbe  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
000bc0  b909              CBNZ     r1,|L1.3014|
;;;3401   			{
;;;3402   				xReturn = taskSCHEDULER_RUNNING;
000bc2  2002              MOVS     r0,#2
000bc4  e000              B        |L1.3016|
                  |L1.3014|
;;;3403   			}
;;;3404   			else
;;;3405   			{
;;;3406   				xReturn = taskSCHEDULER_SUSPENDED;
000bc6  2000              MOVS     r0,#0
                  |L1.3016|
;;;3407   			}
;;;3408   		}
;;;3409   
;;;3410   		return xReturn;
;;;3411   	}
000bc8  4770              BX       lr
;;;3412   
                          ENDP

                  uxTaskResetEventItemValue PROC
;;;3867   
;;;3868   TickType_t uxTaskResetEventItemValue( void )
000bca  4939              LDR      r1,|L1.3248|
;;;3869   {
;;;3870   TickType_t uxReturn;
;;;3871   
;;;3872   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000bcc  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000bce  6988              LDR      r0,[r1,#0x18]
;;;3873   
;;;3874   	/* Reset the event list item to its normal value - so it can be used with
;;;3875   	queues and semaphores. */
;;;3876   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000bd0  4937              LDR      r1,|L1.3248|
000bd2  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000bd4  6ac9              LDR      r1,[r1,#0x2c]
000bd6  f1c10105          RSB      r1,r1,#5
000bda  4a35              LDR      r2,|L1.3248|
000bdc  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000bde  6191              STR      r1,[r2,#0x18]
;;;3877   
;;;3878   	return uxReturn;
;;;3879   }
000be0  4770              BX       lr
;;;3880   /*-----------------------------------------------------------*/
                          ENDP

                  ulTaskNotifyTake PROC
;;;3900   
;;;3901   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000be2  e92d41f0          PUSH     {r4-r8,lr}
;;;3902   	{
000be6  4606              MOV      r6,r0
000be8  460c              MOV      r4,r1
;;;3903   	TickType_t xTimeToWake;
;;;3904   	uint32_t ulReturn;
;;;3905   
;;;3906   		taskENTER_CRITICAL();
000bea  f7fffffe          BL       vPortEnterCritical
;;;3907   		{
;;;3908   			/* Only block if the notification count is not already non-zero. */
;;;3909   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
000bee  4830              LDR      r0,|L1.3248|
000bf0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000bf2  6c40              LDR      r0,[r0,#0x44]
000bf4  bb30              CBNZ     r0,|L1.3140|
;;;3910   			{
;;;3911   				/* Mark this task as waiting for a notification. */
;;;3912   				pxCurrentTCB->eNotifyState = eWaitingNotification;
000bf6  2001              MOVS     r0,#1
000bf8  492d              LDR      r1,|L1.3248|
000bfa  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000bfc  f8810048          STRB     r0,[r1,#0x48]
;;;3913   
;;;3914   				if( xTicksToWait > ( TickType_t ) 0 )
000c00  b304              CBZ      r4,|L1.3140|
;;;3915   				{
;;;3916   					/* The task is going to block.  First it must be removed
;;;3917   					from the ready list. */
;;;3918   					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000c02  482b              LDR      r0,|L1.3248|
000c04  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000c06  1d00              ADDS     r0,r0,#4
000c08  f7fffffe          BL       uxListRemove
000c0c  b948              CBNZ     r0,|L1.3106|
;;;3919   					{
;;;3920   						/* The current task must be in a ready list, so there is
;;;3921   						no need to check, and the port reset macro can be called
;;;3922   						directly. */
;;;3923   						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000c0e  4828              LDR      r0,|L1.3248|
000c10  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000c12  6ac1              LDR      r1,[r0,#0x2c]
000c14  2001              MOVS     r0,#1
000c16  4088              LSLS     r0,r0,r1
000c18  4926              LDR      r1,|L1.3252|
000c1a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000c1c  4381              BICS     r1,r1,r0
000c1e  4825              LDR      r0,|L1.3252|
000c20  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.3106|
;;;3924   					}
;;;3925   					else
;;;3926   					{
;;;3927   						mtCOVERAGE_TEST_MARKER();
;;;3928   					}
;;;3929   
;;;3930   					#if ( INCLUDE_vTaskSuspend == 1 )
;;;3931   					{
;;;3932   						if( xTicksToWait == portMAX_DELAY )
000c22  1c60              ADDS     r0,r4,#1
000c24  d106              BNE      |L1.3124|
;;;3933   						{
;;;3934   							/* Add the task to the suspended task list instead
;;;3935   							of a delayed task list to ensure the task is not
;;;3936   							woken by a timing event.  It will block
;;;3937   							indefinitely. */
;;;3938   							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000c26  4822              LDR      r0,|L1.3248|
000c28  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000c2a  1d09              ADDS     r1,r1,#4
000c2c  4822              LDR      r0,|L1.3256|
000c2e  f7fffffe          BL       vListInsertEnd
000c32  e005              B        |L1.3136|
                  |L1.3124|
;;;3939   						}
;;;3940   						else
;;;3941   						{
;;;3942   							/* Calculate the time at which the task should be
;;;3943   							woken if no notification events occur.  This may
;;;3944   							overflow but this doesn't matter, the scheduler will
;;;3945   							handle it. */
;;;3946   							xTimeToWake = xTickCount + xTicksToWait;
000c34  481d              LDR      r0,|L1.3244|
000c36  6800              LDR      r0,[r0,#0]  ; xTickCount
000c38  1907              ADDS     r7,r0,r4
;;;3947   							prvAddCurrentTaskToDelayedList( xTimeToWake );
000c3a  4638              MOV      r0,r7
000c3c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.3136|
;;;3948   						}
;;;3949   					}
;;;3950   					#else /* INCLUDE_vTaskSuspend */
;;;3951   					{
;;;3952   							/* Calculate the time at which the task should be
;;;3953   							woken if the event does not occur.  This may
;;;3954   							overflow but this doesn't matter, the scheduler will
;;;3955   							handle it. */
;;;3956   							xTimeToWake = xTickCount + xTicksToWait;
;;;3957   							prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;3958   					}
;;;3959   					#endif /* INCLUDE_vTaskSuspend */
;;;3960   
;;;3961   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;3962   
;;;3963   					/* All ports are written to allow a yield in a critical
;;;3964   					section (some will yield immediately, others wait until the
;;;3965   					critical section exits) - but it is not something that
;;;3966   					application code should ever do. */
;;;3967   					portYIELD_WITHIN_API();
000c40  f7fffffe          BL       vPortYield
                  |L1.3140|
;;;3968   				}
;;;3969   				else
;;;3970   				{
;;;3971   					mtCOVERAGE_TEST_MARKER();
;;;3972   				}
;;;3973   			}
;;;3974   			else
;;;3975   			{
;;;3976   				mtCOVERAGE_TEST_MARKER();
;;;3977   			}
;;;3978   		}
;;;3979   		taskEXIT_CRITICAL();
000c44  f7fffffe          BL       vPortExitCritical
;;;3980   
;;;3981   		taskENTER_CRITICAL();
000c48  f7fffffe          BL       vPortEnterCritical
;;;3982   		{
;;;3983   			traceTASK_NOTIFY_TAKE();
;;;3984   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000c4c  4818              LDR      r0,|L1.3248|
000c4e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000c50  6c45              LDR      r5,[r0,#0x44]
;;;3985   
;;;3986   			if( ulReturn != 0UL )
000c52  b165              CBZ      r5,|L1.3182|
;;;3987   			{
;;;3988   				if( xClearCountOnExit != pdFALSE )
000c54  b126              CBZ      r6,|L1.3168|
;;;3989   				{
;;;3990   					pxCurrentTCB->ulNotifiedValue = 0UL;
000c56  2000              MOVS     r0,#0
000c58  4915              LDR      r1,|L1.3248|
000c5a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000c5c  6448              STR      r0,[r1,#0x44]
000c5e  e006              B        |L1.3182|
                  |L1.3168|
;;;3991   				}
;;;3992   				else
;;;3993   				{
;;;3994   					( pxCurrentTCB->ulNotifiedValue )--;
000c60  4913              LDR      r1,|L1.3248|
000c62  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000c64  f1010044          ADD      r0,r1,#0x44
000c68  6c49              LDR      r1,[r1,#0x44]
000c6a  1e49              SUBS     r1,r1,#1
000c6c  6001              STR      r1,[r0,#0]
                  |L1.3182|
;;;3995   				}
;;;3996   			}
;;;3997   			else
;;;3998   			{
;;;3999   				mtCOVERAGE_TEST_MARKER();
;;;4000   			}
;;;4001   
;;;4002   			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
000c6e  2000              MOVS     r0,#0
000c70  490f              LDR      r1,|L1.3248|
000c72  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000c74  f8810048          STRB     r0,[r1,#0x48]
;;;4003   		}
;;;4004   		taskEXIT_CRITICAL();
000c78  f7fffffe          BL       vPortExitCritical
;;;4005   
;;;4006   		return ulReturn;
000c7c  4628              MOV      r0,r5
;;;4007   	}
000c7e  e8bd81f0          POP      {r4-r8,pc}
000c82  0000              DCW      0x0000
                  |L1.3204|
                          DCD      xPendingReadyList
                  |L1.3208|
                          DCD      xTasksWaitingTermination
                  |L1.3212|
                          DCD      uxCurrentNumberOfTasks
                  |L1.3216|
                          DCD      uxTasksDeleted
                  |L1.3220|
                          DCD      pxReadyTasksLists
                  |L1.3224|
000c98  49444c45          DCB      "IDLE",0
000c9c  00      
000c9d  00                DCB      0
000c9e  00                DCB      0
000c9f  00                DCB      0
                  |L1.3232|
                          DCD      prvIdleTask
                  |L1.3236|
                          DCD      xNextTaskUnblockTime
                  |L1.3240|
                          DCD      xSchedulerRunning
                  |L1.3244|
                          DCD      xTickCount
                  |L1.3248|
                          DCD      pxCurrentTCB
                  |L1.3252|
                          DCD      uxTopReadyPriority
                  |L1.3256|
                          DCD      xSuspendedTaskList
                  |L1.3260|
                          DCD      uxSchedulerSuspended
                  |L1.3264|
                          DCD      xYieldPending
                  |L1.3268|
                          DCD      xNumOfOverflows
                          ENDP

                  xTaskNotifyWait PROC
;;;4013   
;;;4014   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000cc8  e92d47f0          PUSH     {r4-r10,lr}
;;;4015   	{
000ccc  4607              MOV      r7,r0
000cce  4688              MOV      r8,r1
000cd0  4615              MOV      r5,r2
000cd2  461c              MOV      r4,r3
;;;4016   	TickType_t xTimeToWake;
;;;4017   	BaseType_t xReturn;
;;;4018   
;;;4019   		taskENTER_CRITICAL();
000cd4  f7fffffe          BL       vPortEnterCritical
;;;4020   		{
;;;4021   			/* Only block if a notification is not already pending. */
;;;4022   			if( pxCurrentTCB->eNotifyState != eNotified )
000cd8  48b1              LDR      r0,|L1.4000|
000cda  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000cdc  f8900048          LDRB     r0,[r0,#0x48]
000ce0  2802              CMP      r0,#2
000ce2  d02e              BEQ      |L1.3394|
;;;4023   			{
;;;4024   				/* Clear bits in the task's notification value as bits may get
;;;4025   				set	by the notifying task or interrupt.  This can be used to
;;;4026   				clear the value to zero. */
;;;4027   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
000ce4  49ae              LDR      r1,|L1.4000|
000ce6  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000ce8  f1010044          ADD      r0,r1,#0x44
000cec  6c49              LDR      r1,[r1,#0x44]
000cee  43b9              BICS     r1,r1,r7
000cf0  6001              STR      r1,[r0,#0]
;;;4028   
;;;4029   				/* Mark this task as waiting for a notification. */
;;;4030   				pxCurrentTCB->eNotifyState = eWaitingNotification;
000cf2  2001              MOVS     r0,#1
000cf4  49aa              LDR      r1,|L1.4000|
000cf6  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000cf8  f8810048          STRB     r0,[r1,#0x48]
;;;4031   
;;;4032   				if( xTicksToWait > ( TickType_t ) 0 )
000cfc  b30c              CBZ      r4,|L1.3394|
;;;4033   				{
;;;4034   					/* The task is going to block.  First it must be removed
;;;4035   					from the	ready list. */
;;;4036   					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000cfe  48a8              LDR      r0,|L1.4000|
000d00  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000d02  1d00              ADDS     r0,r0,#4
000d04  f7fffffe          BL       uxListRemove
000d08  b948              CBNZ     r0,|L1.3358|
;;;4037   					{
;;;4038   						/* The current task must be in a ready list, so there is
;;;4039   						no need to check, and the port reset macro can be called
;;;4040   						directly. */
;;;4041   						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000d0a  48a5              LDR      r0,|L1.4000|
000d0c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000d0e  6ac1              LDR      r1,[r0,#0x2c]
000d10  2001              MOVS     r0,#1
000d12  4088              LSLS     r0,r0,r1
000d14  49a3              LDR      r1,|L1.4004|
000d16  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000d18  4381              BICS     r1,r1,r0
000d1a  48a2              LDR      r0,|L1.4004|
000d1c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.3358|
;;;4042   					}
;;;4043   					else
;;;4044   					{
;;;4045   						mtCOVERAGE_TEST_MARKER();
;;;4046   					}
;;;4047   
;;;4048   					#if ( INCLUDE_vTaskSuspend == 1 )
;;;4049   					{
;;;4050   						if( xTicksToWait == portMAX_DELAY )
000d1e  1c60              ADDS     r0,r4,#1
000d20  d106              BNE      |L1.3376|
;;;4051   						{
;;;4052   							/* Add the task to the suspended task list instead
;;;4053   							of a delayed task list to ensure the task is not
;;;4054   							woken by a timing event.  It will block
;;;4055   							indefinitely. */
;;;4056   							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000d22  489f              LDR      r0,|L1.4000|
000d24  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000d26  1d09              ADDS     r1,r1,#4
000d28  489f              LDR      r0,|L1.4008|
000d2a  f7fffffe          BL       vListInsertEnd
000d2e  e006              B        |L1.3390|
                  |L1.3376|
;;;4057   						}
;;;4058   						else
;;;4059   						{
;;;4060   							/* Calculate the time at which the task should be
;;;4061   							woken if no notification events occur.  This may
;;;4062   							overflow but this doesn't matter, the scheduler will
;;;4063   							handle it. */
;;;4064   							xTimeToWake = xTickCount + xTicksToWait;
000d30  489e              LDR      r0,|L1.4012|
000d32  6800              LDR      r0,[r0,#0]  ; xTickCount
000d34  eb000904          ADD      r9,r0,r4
;;;4065   							prvAddCurrentTaskToDelayedList( xTimeToWake );
000d38  4648              MOV      r0,r9
000d3a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.3390|
;;;4066   						}
;;;4067   					}
;;;4068   					#else /* INCLUDE_vTaskSuspend */
;;;4069   					{
;;;4070   							/* Calculate the time at which the task should be
;;;4071   							woken if the event does not occur.  This may
;;;4072   							overflow but this doesn't matter, the scheduler will
;;;4073   							handle it. */
;;;4074   							xTimeToWake = xTickCount + xTicksToWait;
;;;4075   							prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;4076   					}
;;;4077   					#endif /* INCLUDE_vTaskSuspend */
;;;4078   
;;;4079   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4080   
;;;4081   					/* All ports are written to allow a yield in a critical
;;;4082   					section (some will yield immediately, others wait until the
;;;4083   					critical section exits) - but it is not something that
;;;4084   					application code should ever do. */
;;;4085   					portYIELD_WITHIN_API();
000d3e  f7fffffe          BL       vPortYield
                  |L1.3394|
;;;4086   				}
;;;4087   				else
;;;4088   				{
;;;4089   					mtCOVERAGE_TEST_MARKER();
;;;4090   				}
;;;4091   			}
;;;4092   			else
;;;4093   			{
;;;4094   				mtCOVERAGE_TEST_MARKER();
;;;4095   			}
;;;4096   		}
;;;4097   		taskEXIT_CRITICAL();
000d42  f7fffffe          BL       vPortExitCritical
;;;4098   
;;;4099   		taskENTER_CRITICAL();
000d46  f7fffffe          BL       vPortEnterCritical
;;;4100   		{
;;;4101   			traceTASK_NOTIFY_WAIT();
;;;4102   
;;;4103   			if( pulNotificationValue != NULL )
000d4a  b11d              CBZ      r5,|L1.3412|
;;;4104   			{
;;;4105   				/* Output the current notification value, which may or may not
;;;4106   				have changed. */
;;;4107   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000d4c  4894              LDR      r0,|L1.4000|
000d4e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000d50  6c40              LDR      r0,[r0,#0x44]
000d52  6028              STR      r0,[r5,#0]
                  |L1.3412|
;;;4108   			}
;;;4109   
;;;4110   			/* If eNotifyValue is set then either the task never entered the
;;;4111   			blocked state (because a notification was already pending) or the
;;;4112   			task unblocked because of a notification.  Otherwise the task
;;;4113   			unblocked because of a timeout. */
;;;4114   			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
000d54  4892              LDR      r0,|L1.4000|
000d56  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000d58  f8900048          LDRB     r0,[r0,#0x48]
000d5c  2801              CMP      r0,#1
000d5e  d101              BNE      |L1.3428|
;;;4115   			{
;;;4116   				/* A notification was not received. */
;;;4117   				xReturn = pdFALSE;
000d60  2600              MOVS     r6,#0
000d62  e008              B        |L1.3446|
                  |L1.3428|
;;;4118   			}
;;;4119   			else
;;;4120   			{
;;;4121   				/* A notification was already pending or a notification was
;;;4122   				received while the task was waiting. */
;;;4123   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000d64  498e              LDR      r1,|L1.4000|
000d66  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000d68  f1010044          ADD      r0,r1,#0x44
000d6c  6c49              LDR      r1,[r1,#0x44]
000d6e  ea210108          BIC      r1,r1,r8
000d72  6001              STR      r1,[r0,#0]
;;;4124   				xReturn = pdTRUE;
000d74  2601              MOVS     r6,#1
                  |L1.3446|
;;;4125   			}
;;;4126   
;;;4127   			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
000d76  2000              MOVS     r0,#0
000d78  4989              LDR      r1,|L1.4000|
000d7a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000d7c  f8810048          STRB     r0,[r1,#0x48]
;;;4128   		}
;;;4129   		taskEXIT_CRITICAL();
000d80  f7fffffe          BL       vPortExitCritical
;;;4130   
;;;4131   		return xReturn;
000d84  4630              MOV      r0,r6
;;;4132   	}
000d86  e8bd87f0          POP      {r4-r10,pc}
;;;4133   
                          ENDP

                  xTaskGenericNotify PROC
;;;4138   
;;;4139   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000d8a  e92d47f0          PUSH     {r4-r10,lr}
;;;4140   	{
000d8e  4681              MOV      r9,r0
000d90  460d              MOV      r5,r1
000d92  4616              MOV      r6,r2
000d94  461f              MOV      r7,r3
;;;4141   	TCB_t * pxTCB;
;;;4142   	eNotifyValue eOriginalNotifyState;
;;;4143   	BaseType_t xReturn = pdPASS;
000d96  f04f0a01          MOV      r10,#1
;;;4144   
;;;4145   		configASSERT( xTaskToNotify );
;;;4146   		pxTCB = ( TCB_t * ) xTaskToNotify;
000d9a  464c              MOV      r4,r9
;;;4147   
;;;4148   		taskENTER_CRITICAL();
000d9c  f7fffffe          BL       vPortEnterCritical
;;;4149   		{
;;;4150   			if( pulPreviousNotificationValue != NULL )
000da0  b10f              CBZ      r7,|L1.3494|
;;;4151   			{
;;;4152   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000da2  6c60              LDR      r0,[r4,#0x44]
000da4  6038              STR      r0,[r7,#0]
                  |L1.3494|
;;;4153   			}
;;;4154   
;;;4155   			eOriginalNotifyState = pxTCB->eNotifyState;
000da6  f8948048          LDRB     r8,[r4,#0x48]
;;;4156   
;;;4157   			pxTCB->eNotifyState = eNotified;
000daa  2002              MOVS     r0,#2
000dac  f8840048          STRB     r0,[r4,#0x48]
;;;4158   
;;;4159   			switch( eAction )
000db0  2e05              CMP      r6,#5
000db2  d217              BCS      |L1.3556|
000db4  e8dff006          TBB      [pc,r6]
000db8  1503070b          DCB      0x15,0x03,0x07,0x0b
000dbc  0d00              DCB      0x0d,0x00
;;;4160   			{
;;;4161   				case eSetBits	:
;;;4162   					pxTCB->ulNotifiedValue |= ulValue;
000dbe  6c60              LDR      r0,[r4,#0x44]
000dc0  4328              ORRS     r0,r0,r5
000dc2  6460              STR      r0,[r4,#0x44]
;;;4163   					break;
000dc4  e00e              B        |L1.3556|
;;;4164   
;;;4165   				case eIncrement	:
;;;4166   					( pxTCB->ulNotifiedValue )++;
000dc6  6c60              LDR      r0,[r4,#0x44]
000dc8  1c40              ADDS     r0,r0,#1
000dca  6460              STR      r0,[r4,#0x44]
;;;4167   					break;
000dcc  e00a              B        |L1.3556|
;;;4168   
;;;4169   				case eSetValueWithOverwrite	:
;;;4170   					pxTCB->ulNotifiedValue = ulValue;
000dce  6465              STR      r5,[r4,#0x44]
;;;4171   					break;
000dd0  e008              B        |L1.3556|
;;;4172   
;;;4173   				case eSetValueWithoutOverwrite :
;;;4174   					if( eOriginalNotifyState != eNotified )
000dd2  f1b80f02          CMP      r8,#2
000dd6  d001              BEQ      |L1.3548|
;;;4175   					{
;;;4176   						pxTCB->ulNotifiedValue = ulValue;
000dd8  6465              STR      r5,[r4,#0x44]
000dda  e001              B        |L1.3552|
                  |L1.3548|
;;;4177   					}
;;;4178   					else
;;;4179   					{
;;;4180   						/* The value could not be written to the task. */
;;;4181   						xReturn = pdFAIL;
000ddc  f04f0a00          MOV      r10,#0
                  |L1.3552|
;;;4182   					}
;;;4183   					break;
000de0  e000              B        |L1.3556|
;;;4184   
;;;4185   				case eNoAction:
;;;4186   					/* The task is being notified without its notify value being
;;;4187   					updated. */
;;;4188   					break;
000de2  bf00              NOP      
                  |L1.3556|
000de4  bf00              NOP                            ;4163
;;;4189   			}
;;;4190   
;;;4191   			traceTASK_NOTIFY();
;;;4192   
;;;4193   			/* If the task is in the blocked state specifically to wait for a
;;;4194   			notification then unblock it now. */
;;;4195   			if( eOriginalNotifyState == eWaitingNotification )
000de6  f1b80f01          CMP      r8,#1
000dea  d11b              BNE      |L1.3620|
;;;4196   			{
;;;4197   				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000dec  1d20              ADDS     r0,r4,#4
000dee  f7fffffe          BL       uxListRemove
;;;4198   				prvAddTaskToReadyList( pxTCB );
000df2  2001              MOVS     r0,#1
000df4  6ae1              LDR      r1,[r4,#0x2c]
000df6  4088              LSLS     r0,r0,r1
000df8  496a              LDR      r1,|L1.4004|
000dfa  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000dfc  4308              ORRS     r0,r0,r1
000dfe  4969              LDR      r1,|L1.4004|
000e00  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000e02  6ae1              LDR      r1,[r4,#0x2c]
000e04  eb010181          ADD      r1,r1,r1,LSL #2
000e08  4a69              LDR      r2,|L1.4016|
000e0a  eb020081          ADD      r0,r2,r1,LSL #2
000e0e  1d21              ADDS     r1,r4,#4
000e10  f7fffffe          BL       vListInsertEnd
;;;4199   
;;;4200   				/* The task should not have been on an event list. */
;;;4201   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4202   
;;;4203   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4204   				{
;;;4205   					/* If a task is blocked waiting for a notification then
;;;4206   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4207   					out time.  If the task is unblocked for a reason other than
;;;4208   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4209   					because it will automatically get reset to a new value when
;;;4210   					the tick count equals xNextTaskUnblockTime.  However if
;;;4211   					tickless idling is used it might be more important to enter
;;;4212   					sleep mode at the earliest possible time - so reset
;;;4213   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4214   					earliest possible time. */
;;;4215   					prvResetNextTaskUnblockTime();
;;;4216   				}
;;;4217   				#endif
;;;4218   
;;;4219   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000e14  4962              LDR      r1,|L1.4000|
000e16  6ae0              LDR      r0,[r4,#0x2c]
000e18  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000e1a  6ac9              LDR      r1,[r1,#0x2c]
000e1c  4288              CMP      r0,r1
000e1e  d901              BLS      |L1.3620|
;;;4220   				{
;;;4221   					/* The notified task has a priority above the currently
;;;4222   					executing task so a yield is required. */
;;;4223   					taskYIELD_IF_USING_PREEMPTION();
000e20  f7fffffe          BL       vPortYield
                  |L1.3620|
;;;4224   				}
;;;4225   				else
;;;4226   				{
;;;4227   					mtCOVERAGE_TEST_MARKER();
;;;4228   				}
;;;4229   			}
;;;4230   			else
;;;4231   			{
;;;4232   				mtCOVERAGE_TEST_MARKER();
;;;4233   			}
;;;4234   		}
;;;4235   		taskEXIT_CRITICAL();
000e24  f7fffffe          BL       vPortExitCritical
;;;4236   
;;;4237   		return xReturn;
000e28  4650              MOV      r0,r10
;;;4238   	}
000e2a  e8bd87f0          POP      {r4-r10,pc}
;;;4239   
                          ENDP

                  xTaskGenericNotifyFromISR PROC
;;;4244   
;;;4245   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000e2e  e92d4ff8          PUSH     {r3-r11,lr}
;;;4246   	{
000e32  4681              MOV      r9,r0
000e34  460d              MOV      r5,r1
000e36  4616              MOV      r6,r2
000e38  461f              MOV      r7,r3
000e3a  f8dda028          LDR      r10,[sp,#0x28]
;;;4247   	TCB_t * pxTCB;
;;;4248   	eNotifyValue eOriginalNotifyState;
;;;4249   	BaseType_t xReturn = pdPASS;
000e3e  f04f0b01          MOV      r11,#1
;;;4250   	UBaseType_t uxSavedInterruptStatus;
;;;4251   
;;;4252   		configASSERT( xTaskToNotify );
;;;4253   
;;;4254   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4255   		maximum	system call (or maximum API call) interrupt priority.
;;;4256   		Interrupts that are	above the maximum system call priority are keep
;;;4257   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4258   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4259   		is defined in FreeRTOSConfig.h then
;;;4260   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4261   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4262   		been assigned a priority above the configured maximum system call
;;;4263   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4264   		from interrupts	that have been assigned a priority at or (logically)
;;;4265   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4266   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4267   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4268   		provided on the following link:
;;;4269   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4270   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4271   
;;;4272   		pxTCB = ( TCB_t * ) xTaskToNotify;
000e42  464c              MOV      r4,r9
;;;4273   
;;;4274   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000e44  f7fffffe          BL       ulPortSetInterruptMask
000e48  9000              STR      r0,[sp,#0]
;;;4275   		{
;;;4276   			if( pulPreviousNotificationValue != NULL )
000e4a  b10f              CBZ      r7,|L1.3664|
;;;4277   			{
;;;4278   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000e4c  6c60              LDR      r0,[r4,#0x44]
000e4e  6038              STR      r0,[r7,#0]
                  |L1.3664|
;;;4279   			}
;;;4280   
;;;4281   			eOriginalNotifyState = pxTCB->eNotifyState;
000e50  f8948048          LDRB     r8,[r4,#0x48]
;;;4282   			pxTCB->eNotifyState = eNotified;
000e54  2002              MOVS     r0,#2
000e56  f8840048          STRB     r0,[r4,#0x48]
;;;4283   
;;;4284   			switch( eAction )
000e5a  2e05              CMP      r6,#5
000e5c  d217              BCS      |L1.3726|
000e5e  e8dff006          TBB      [pc,r6]
000e62  1503              DCB      0x15,0x03
000e64  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4285   			{
;;;4286   				case eSetBits	:
;;;4287   					pxTCB->ulNotifiedValue |= ulValue;
000e68  6c60              LDR      r0,[r4,#0x44]
000e6a  4328              ORRS     r0,r0,r5
000e6c  6460              STR      r0,[r4,#0x44]
;;;4288   					break;
000e6e  e00e              B        |L1.3726|
;;;4289   
;;;4290   				case eIncrement	:
;;;4291   					( pxTCB->ulNotifiedValue )++;
000e70  6c60              LDR      r0,[r4,#0x44]
000e72  1c40              ADDS     r0,r0,#1
000e74  6460              STR      r0,[r4,#0x44]
;;;4292   					break;
000e76  e00a              B        |L1.3726|
;;;4293   
;;;4294   				case eSetValueWithOverwrite	:
;;;4295   					pxTCB->ulNotifiedValue = ulValue;
000e78  6465              STR      r5,[r4,#0x44]
;;;4296   					break;
000e7a  e008              B        |L1.3726|
;;;4297   
;;;4298   				case eSetValueWithoutOverwrite :
;;;4299   					if( eOriginalNotifyState != eNotified )
000e7c  f1b80f02          CMP      r8,#2
000e80  d001              BEQ      |L1.3718|
;;;4300   					{
;;;4301   						pxTCB->ulNotifiedValue = ulValue;
000e82  6465              STR      r5,[r4,#0x44]
000e84  e001              B        |L1.3722|
                  |L1.3718|
;;;4302   					}
;;;4303   					else
;;;4304   					{
;;;4305   						/* The value could not be written to the task. */
;;;4306   						xReturn = pdFAIL;
000e86  f04f0b00          MOV      r11,#0
                  |L1.3722|
;;;4307   					}
;;;4308   					break;
000e8a  e000              B        |L1.3726|
;;;4309   
;;;4310   				case eNoAction :
;;;4311   					/* The task is being notified without its notify value being
;;;4312   					updated. */
;;;4313   					break;
000e8c  bf00              NOP      
                  |L1.3726|
000e8e  bf00              NOP                            ;4288
;;;4314   			}
;;;4315   
;;;4316   			traceTASK_NOTIFY_FROM_ISR();
;;;4317   
;;;4318   			/* If the task is in the blocked state specifically to wait for a
;;;4319   			notification then unblock it now. */
;;;4320   			if( eOriginalNotifyState == eWaitingNotification )
000e90  f1b80f01          CMP      r8,#1
000e94  d128              BNE      |L1.3816|
;;;4321   			{
;;;4322   				/* The task should not have been on an event list. */
;;;4323   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4324   
;;;4325   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000e96  4847              LDR      r0,|L1.4020|
000e98  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000e9a  b9a0              CBNZ     r0,|L1.3782|
;;;4326   				{
;;;4327   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000e9c  1d20              ADDS     r0,r4,#4
000e9e  f7fffffe          BL       uxListRemove
;;;4328   					prvAddTaskToReadyList( pxTCB );
000ea2  2001              MOVS     r0,#1
000ea4  6ae1              LDR      r1,[r4,#0x2c]
000ea6  4088              LSLS     r0,r0,r1
000ea8  493e              LDR      r1,|L1.4004|
000eaa  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000eac  4308              ORRS     r0,r0,r1
000eae  493d              LDR      r1,|L1.4004|
000eb0  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000eb2  6ae1              LDR      r1,[r4,#0x2c]
000eb4  eb010181          ADD      r1,r1,r1,LSL #2
000eb8  4a3d              LDR      r2,|L1.4016|
000eba  eb020081          ADD      r0,r2,r1,LSL #2
000ebe  1d21              ADDS     r1,r4,#4
000ec0  f7fffffe          BL       vListInsertEnd
000ec4  e004              B        |L1.3792|
                  |L1.3782|
;;;4329   				}
;;;4330   				else
;;;4331   				{
;;;4332   					/* The delayed and ready lists cannot be accessed, so hold
;;;4333   					this task pending until the scheduler is resumed. */
;;;4334   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000ec6  f1040118          ADD      r1,r4,#0x18
000eca  483b              LDR      r0,|L1.4024|
000ecc  f7fffffe          BL       vListInsertEnd
                  |L1.3792|
;;;4335   				}
;;;4336   
;;;4337   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000ed0  4933              LDR      r1,|L1.4000|
000ed2  6ae0              LDR      r0,[r4,#0x2c]
000ed4  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000ed6  6ac9              LDR      r1,[r1,#0x2c]
000ed8  4288              CMP      r0,r1
000eda  d905              BLS      |L1.3816|
;;;4338   				{
;;;4339   					/* The notified task has a priority above the currently
;;;4340   					executing task so a yield is required. */
;;;4341   					if( pxHigherPriorityTaskWoken != NULL )
000edc  f1ba0f00          CMP      r10,#0
000ee0  d002              BEQ      |L1.3816|
;;;4342   					{
;;;4343   						*pxHigherPriorityTaskWoken = pdTRUE;
000ee2  2001              MOVS     r0,#1
000ee4  f8ca0000          STR      r0,[r10,#0]
                  |L1.3816|
;;;4344   					}
;;;4345   				}
;;;4346   				else
;;;4347   				{
;;;4348   					mtCOVERAGE_TEST_MARKER();
;;;4349   				}
;;;4350   			}
;;;4351   		}
;;;4352   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000ee8  9800              LDR      r0,[sp,#0]
000eea  f7fffffe          BL       vPortClearInterruptMask
;;;4353   
;;;4354   		return xReturn;
000eee  4658              MOV      r0,r11
;;;4355   	}
000ef0  e8bd8ff8          POP      {r3-r11,pc}
;;;4356   
                          ENDP

                  vTaskNotifyGiveFromISR PROC
;;;4361   
;;;4362   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000ef4  e92d41f0          PUSH     {r4-r8,lr}
;;;4363   	{
000ef8  4605              MOV      r5,r0
000efa  460e              MOV      r6,r1
;;;4364   	TCB_t * pxTCB;
;;;4365   	eNotifyValue eOriginalNotifyState;
;;;4366   	UBaseType_t uxSavedInterruptStatus;
;;;4367   
;;;4368   		configASSERT( xTaskToNotify );
;;;4369   
;;;4370   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4371   		maximum	system call (or maximum API call) interrupt priority.
;;;4372   		Interrupts that are	above the maximum system call priority are keep
;;;4373   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4374   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4375   		is defined in FreeRTOSConfig.h then
;;;4376   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4377   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4378   		been assigned a priority above the configured maximum system call
;;;4379   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4380   		from interrupts	that have been assigned a priority at or (logically)
;;;4381   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4382   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4383   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4384   		provided on the following link:
;;;4385   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4386   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4387   
;;;4388   		pxTCB = ( TCB_t * ) xTaskToNotify;
000efc  462c              MOV      r4,r5
;;;4389   
;;;4390   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000efe  f7fffffe          BL       ulPortSetInterruptMask
000f02  4680              MOV      r8,r0
;;;4391   		{
;;;4392   			eOriginalNotifyState = pxTCB->eNotifyState;
000f04  f8947048          LDRB     r7,[r4,#0x48]
;;;4393   			pxTCB->eNotifyState = eNotified;
000f08  2002              MOVS     r0,#2
000f0a  f8840048          STRB     r0,[r4,#0x48]
;;;4394   
;;;4395   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4396   			semaphore. */
;;;4397   			( pxTCB->ulNotifiedValue )++;
000f0e  6c60              LDR      r0,[r4,#0x44]
000f10  1c40              ADDS     r0,r0,#1
000f12  6460              STR      r0,[r4,#0x44]
;;;4398   
;;;4399   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4400   
;;;4401   			/* If the task is in the blocked state specifically to wait for a
;;;4402   			notification then unblock it now. */
;;;4403   			if( eOriginalNotifyState == eWaitingNotification )
000f14  2f01              CMP      r7,#1
000f16  d125              BNE      |L1.3940|
;;;4404   			{
;;;4405   				/* The task should not have been on an event list. */
;;;4406   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4407   
;;;4408   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000f18  4826              LDR      r0,|L1.4020|
000f1a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000f1c  b9a0              CBNZ     r0,|L1.3912|
;;;4409   				{
;;;4410   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000f1e  1d20              ADDS     r0,r4,#4
000f20  f7fffffe          BL       uxListRemove
;;;4411   					prvAddTaskToReadyList( pxTCB );
000f24  2001              MOVS     r0,#1
000f26  6ae1              LDR      r1,[r4,#0x2c]
000f28  4088              LSLS     r0,r0,r1
000f2a  491e              LDR      r1,|L1.4004|
000f2c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000f2e  4308              ORRS     r0,r0,r1
000f30  491c              LDR      r1,|L1.4004|
000f32  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000f34  6ae1              LDR      r1,[r4,#0x2c]
000f36  eb010181          ADD      r1,r1,r1,LSL #2
000f3a  4a1d              LDR      r2,|L1.4016|
000f3c  eb020081          ADD      r0,r2,r1,LSL #2
000f40  1d21              ADDS     r1,r4,#4
000f42  f7fffffe          BL       vListInsertEnd
000f46  e004              B        |L1.3922|
                  |L1.3912|
;;;4412   				}
;;;4413   				else
;;;4414   				{
;;;4415   					/* The delayed and ready lists cannot be accessed, so hold
;;;4416   					this task pending until the scheduler is resumed. */
;;;4417   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000f48  f1040118          ADD      r1,r4,#0x18
000f4c  481a              LDR      r0,|L1.4024|
000f4e  f7fffffe          BL       vListInsertEnd
                  |L1.3922|
;;;4418   				}
;;;4419   
;;;4420   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000f52  4913              LDR      r1,|L1.4000|
000f54  6ae0              LDR      r0,[r4,#0x2c]
000f56  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000f58  6ac9              LDR      r1,[r1,#0x2c]
000f5a  4288              CMP      r0,r1
000f5c  d902              BLS      |L1.3940|
;;;4421   				{
;;;4422   					/* The notified task has a priority above the currently
;;;4423   					executing task so a yield is required. */
;;;4424   					if( pxHigherPriorityTaskWoken != NULL )
000f5e  b10e              CBZ      r6,|L1.3940|
;;;4425   					{
;;;4426   						*pxHigherPriorityTaskWoken = pdTRUE;
000f60  2001              MOVS     r0,#1
000f62  6030              STR      r0,[r6,#0]
                  |L1.3940|
;;;4427   					}
;;;4428   				}
;;;4429   				else
;;;4430   				{
;;;4431   					mtCOVERAGE_TEST_MARKER();
;;;4432   				}
;;;4433   			}
;;;4434   		}
;;;4435   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000f64  4640              MOV      r0,r8
000f66  f7fffffe          BL       vPortClearInterruptMask
;;;4436   	}
000f6a  e8bd81f0          POP      {r4-r8,pc}
;;;4437   
                          ENDP

                  xTaskNotifyStateClear PROC
;;;4443   
;;;4444   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000f6e  b570              PUSH     {r4-r6,lr}
;;;4445   	{
000f70  4604              MOV      r4,r0
;;;4446   	TCB_t *pxTCB;
;;;4447   	BaseType_t xReturn;
;;;4448   
;;;4449   		pxTCB = ( TCB_t * ) xTask;
000f72  4626              MOV      r6,r4
;;;4450   
;;;4451   		/* If null is passed in here then it is the calling task that is having
;;;4452   		its notification state cleared. */
;;;4453   		pxTCB = prvGetTCBFromHandle( pxTCB );
000f74  b916              CBNZ     r6,|L1.3964|
000f76  480a              LDR      r0,|L1.4000|
000f78  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000f7a  e000              B        |L1.3966|
                  |L1.3964|
000f7c  4630              MOV      r0,r6
                  |L1.3966|
000f7e  4606              MOV      r6,r0
;;;4454   
;;;4455   		taskENTER_CRITICAL();
000f80  f7fffffe          BL       vPortEnterCritical
;;;4456   		{
;;;4457   			if( pxTCB->eNotifyState == eNotified )
000f84  f8960048          LDRB     r0,[r6,#0x48]
000f88  2802              CMP      r0,#2
000f8a  d104              BNE      |L1.3990|
;;;4458   			{
;;;4459   				pxTCB->eNotifyState = eNotWaitingNotification;
000f8c  2000              MOVS     r0,#0
000f8e  f8860048          STRB     r0,[r6,#0x48]
;;;4460   				xReturn = pdPASS;
000f92  2501              MOVS     r5,#1
000f94  e000              B        |L1.3992|
                  |L1.3990|
;;;4461   			}
;;;4462   			else
;;;4463   			{
;;;4464   				xReturn = pdFAIL;
000f96  2500              MOVS     r5,#0
                  |L1.3992|
;;;4465   			}
;;;4466   		}
;;;4467   		taskEXIT_CRITICAL();
000f98  f7fffffe          BL       vPortExitCritical
;;;4468   
;;;4469   		return xReturn;
000f9c  4628              MOV      r0,r5
;;;4470   	}
000f9e  bd70              POP      {r4-r6,pc}
;;;4471   
                          ENDP

                  |L1.4000|
                          DCD      pxCurrentTCB
                  |L1.4004|
                          DCD      uxTopReadyPriority
                  |L1.4008|
                          DCD      xSuspendedTaskList
                  |L1.4012|
                          DCD      xTickCount
                  |L1.4016|
                          DCD      pxReadyTasksLists
                  |L1.4020|
                          DCD      uxSchedulerSuspended
                  |L1.4024|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
